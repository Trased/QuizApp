[
    {
        "question": "Which of the following are considered classical web components in Java?",
        "options": [
            "Servlets, JSP, Java Beans",
            "JDBC, HTML, CSS",
            "JNDI, JMS, JSON",
            "Tomcat, GlassFish, WildFly"
        ],
        "answer": 0,
        "explanation": "Servlets, JSP, and Java Beans are considered classical web components in Java as they form the core of building dynamic web applications. Servlets handle HTTP requests and responses, JSP is used for embedding Java code in HTML, and Java Beans are reusable software components for encapsulating business logic. The other options include unrelated or higher-level technologies."
    },
    {
        "question": "What is the main purpose of Java Server Pages (JSP)?",
        "options": [
            "To manage application configurations",
            "To simplify the creation of dynamic web pages",
            "To handle HTTP requests and responses",
            "To replace JavaScript on the client side"
        ],
        "answer": 1,
        "explanation": "The main purpose of Java Server Pages (JSP) is to simplify the creation of dynamic web pages by allowing developers to embed Java code directly into HTML. JSP is designed for server-side rendering of content, enabling dynamic data presentation and integration with backend systems. It does not handle application configurations, HTTP requests, or replace JavaScript, which is primarily a client-side language."
    },
    {
        "question": "What type of content can JSP pages contain?",
        "options": [
            "Static content only",
            "Dynamic content only",
            "Static and dynamic content",
            "Only JavaScript code"
        ],
        "answer": 2,
        "explanation": "JSP pages can contain both static and dynamic content. Static content, such as HTML, CSS, or JavaScript, is rendered as-is, while dynamic content is generated on the server using Java code embedded in the JSP. This flexibility allows JSP to build complex, data-driven web pages. It is not limited to only static or dynamic content, nor is it restricted to JavaScript."
    },
    {
        "question": "Which of the following statements about JSP lifecycle is true?",
        "options": [
            "JSP pages are interpreted directly by the web server.",
            "Every JSP page is compiled into a servlet before execution.",
            "JSP pages do not require a servlet container to run.",
            "JSP pages must be written in XML format."
        ],
        "answer": 1,
        "explanation": "Every JSP page is compiled into a servlet before execution. This is a key feature of the JSP lifecycle. When a JSP page is requested for the first time, it is translated into a servlet, compiled, and then executed. JSP pages are not directly interpreted by the web server, require a servlet container to run, and do not need to be written in XML format."
    },
    {
        "question": "What is the purpose of the <% ... %> scriptlet tag in JSP?",
        "options": [
            "To include static content in the page",
            "To execute Java code within the page",
            "To define JSP page directives",
            "To include other JSP pages dynamically"
        ],
        "answer": 1,
        "explanation": "The `<% ... %>` scriptlet tag in JSP is used to execute Java code within the page. Any code inside this tag is embedded into the servlet's `service()` method when the JSP is compiled. It is not used for static content, directives, or dynamic inclusion of other JSP pages, which are handled by other JSP tags or constructs."
    },
    {
        "question": "Which of the following JSP tags is used to declare variables or methods in a page?",
        "options": [
            "<% ... %>",
            "<%= ... %>",
            "<%! ... %>",
            "<%@ ... %>"
        ],
        "answer": 2,
        "explanation": "The `<%! ... %>` tag in JSP is used to declare variables or methods at the class level within the generated servlet. This allows you to define reusable components, such as fields or helper methods, that are available throughout the JSP page. Other tags like `<% ... %>` execute code inside the `service()` method, `<%= ... %>` outputs expressions, and `<%@ ... %>` is used for directives."
    },
    {
        "question": "What is the role of the <jsp:useBean> tag in JSP?",
        "options": [
            "To define a new Java class within the JSP page",
            "To create or access a Java bean instance in the page",
            "To include another JSP page",
            "To manage HTTP sessions"
        ],
        "answer": 1,
        "explanation": "The `<jsp:useBean>` tag in JSP is used to create or access a JavaBean instance within the page. It allows you to instantiate a bean, bind it to a scope (such as `page`, `request`, `session`, or `application`), and interact with its properties. This tag is not used to define new Java classes, include other JSP pages, or manage HTTP sessions."
    },
    {
        "question": "Which tag is used to include another resource (like a JSP or HTML file) in a JSP page?",
        "code_snippet": "<jsp: .... page=\"header.jsp\"/>",
        "options": [
            "<jsp:useBean>",
            "<jsp:forward>",
            "<jsp:include>",
            "<jsp:import>"
        ],
        "answer": 2,
        "explanation": "The `<jsp:include>` tag in JSP is used to include another resource, such as a JSP or HTML file, at runtime. It ensures that the content of the included file is dynamically included every time the parent JSP page is requested. It is commonly used for reusable components like headers or footers. Other tags like `<jsp:useBean>` create or access JavaBeans, `<jsp:forward>` redirects to another resource, and `<jsp:import>` is not a valid JSP tag."
    },
    {
        "question": "What does the <c:forEach> tag from JSTL do?",
        "options": [
            "Defines a loop for iterating over a collection",
            "Imports a resource into the JSP page",
            "Handles conditional rendering based on a test",
            "Formats numbers and dates for internationalization"
        ],
        "answer": 0,
        "explanation": "The `<c:forEach>` tag from the JSTL (JavaServer Pages Standard Tag Library) is used to define a loop for iterating over a collection of items, such as a list, array, or map. It simplifies repetitive tasks in JSP by enabling iteration without needing embedded Java code. Other functionalities, such as importing resources, handling conditions, or formatting numbers and dates, are performed by different JSTL tags."
    },
    {
        "question": "What is the purpose of the Expression Language (EL) in JSP?",
        "options": [
            "To execute Java code directly",
            "To perform logical operations only",
            "To access application data using a simpler syntax",
            "To format date and time values"
        ],
        "answer": 2,
        "explanation": "The purpose of the Expression Language (EL) in JSP is to access application data, such as attributes stored in scopes (e.g., request, session, application), using a simpler and more concise syntax. EL eliminates the need for complex Java code in JSP pages, allowing easy evaluation of expressions, variable references, and logical operations. It is not used for directly executing Java code or exclusively formatting date and time values."
    },
    {
        "question": "What is a benefit of using JSTL (Java Standard Tag Library) in JSP?",
        "options": [
            "Eliminates the need for servlets",
            "Allows execution of Java code directly in JSP pages",
            "Encapsulates common functionalities in reusable tags",
            "Replaces the use of XML in web applications"
        ],
        "answer": 2,
        "explanation": "The Java Standard Tag Library (JSTL) provides a set of reusable tags that encapsulate common functionalities such as iteration, conditional rendering, and internationalization. This simplifies JSP development by reducing the need for Java code in the page, promoting cleaner and more maintainable code. While JSTL improves JSP pages, it does not eliminate servlets or replace XML usage in web applications."
    },
    {
        "question": "Which JSP directive is used to import Java classes into a page?",
        "code_snippet": "<%@ ... import=\"java.util.Date\" %>",
        "options": [
            "<%@ include %>",
            "<%@ import %>",
            "<%@ page %>",
            "<%@ taglib %>"
        ],
        "answer": 2,
        "explanation": "The `<%@ page %>` directive in JSP is used to set page-level instructions, including importing Java classes. The `import` attribute allows you to include Java classes in the JSP page, enabling the use of these classes in the page's logic. Other directives, such as `<%@ include %>` for including files and `<%@ taglib %>` for defining tag libraries, serve different purposes."
    },
    {
        "question": "What is the main purpose of a Custom Tag Library (CTL) in JSP?",
        "options": [
            "To create reusable components with dynamic functionalities",
            "To manage HTTP sessions programmatically",
            "To handle database connections within JSP",
            "To replace all standard JSP tags"
        ],
        "answer": 0,
        "explanation": "The main purpose of a Custom Tag Library (CTL) in JSP is to create reusable components with dynamic functionalities. CTLs allow developers to encapsulate complex logic and functionality into custom tags, which can then be reused across JSP pages, promoting modularity and maintainability. CTLs do not manage HTTP sessions, handle database connections directly, or replace all standard JSP tags."
    },
    {
        "question": "Which tag in JSTL core library is used to conditionally execute content?",
        "code_snippet": "<c: ... test=\"${user.loggedIn}\"> Welcome! </c: ... >",
        "options": [
            "<c:choose>",
            "<c:when>",
            "<c:if>",
            "<c:forEach>"
        ],
        "answer": 2,
       "explanation": "The `<c:if>` tag in the JSTL core library is used to conditionally execute content based on a test condition. The `test` attribute evaluates a boolean expression, and if it evaluates to true, the body of the tag is executed. Other tags like `<c:choose>` and `<c:when>` are used for multi-conditional logic, while `<c:forEach>` is for iteration."
    },
    {
        "question": "What does the <fmt:formatNumber> tag in JSTL do?",
        "code_snippet": "<fmt:formatNumber value=\"1234.56\" type=\"currency\"/>",
        "options": [
            "Performs mathematical operations",
            "Formats numbers for internationalized output",
            "Validates numeric input from the user",
            "Defines a variable for arithmetic calculations"
        ],
        "answer": 1,
        "explanation": "The `<fmt:formatNumber>` tag in JSTL is used to format numbers for internationalized output. It can display numbers in various formats such as currency, percentage, or custom patterns, making it useful for applications that need to support multiple locales. It does not perform mathematical operations, validate numeric input, or define variables for calculations."
    },
    {
        "question": "Which file is typically used to define custom tag libraries in a JSP application?",
        "options": [
            "web.xml",
            "taglib.xml",
            "tld file (Tag Library Descriptor)",
            "jsp-config.xml"
        ],
        "answer": 2,
        "explanation": "The TLD (Tag Library Descriptor) file is used to define custom tag libraries in a JSP application. It provides metadata about the custom tags, such as their names, attributes, and implementation classes. While `web.xml` defines application-wide configurations and `jsp-config.xml` specifies JSP-related settings, the TLD file is specifically designed for tag libraries."
    },
    {
        "question": "What does the <jsp:forward> tag do in a JSP page?",
        "options": [
            "Redirects the client to another URL",
            "Forwards the request to another resource on the server",
            "Handles errors within a JSP page",
            "Executes Java code and prints output"
        ],
        "answer": 1,
        "explanation": "The `<jsp:forward>` tag in JSP is used to forward the current request to another resource on the server, such as another JSP, servlet, or HTML file. Unlike a client-side redirect, forwarding is handled internally on the server, and the client is unaware of the resource change. It does not redirect to an external URL, handle errors, or execute Java code directly."
    },
    {
        "question": "True or False: A JSP page can be dynamically included in another JSP using the <jsp:include> tag.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. The `<jsp:include>` tag allows dynamic inclusion of another JSP page or resource at runtime. This is useful for including reusable components, such as headers, footers, or navigation menus, into a JSP page. The included content is processed each time the parent JSP is requested, ensuring the included content reflects any updates."
    },
    {
        "question": "What is the purpose of the Model-View-Controller (MVC) pattern in web applications?",
        "options": [
            "To separate data, presentation, and business logic layers",
            "To replace the use of servlets with JSP pages",
            "To manage database transactions automatically",
            "To standardize Java syntax for web applications"
        ],
        "answer": 0,
        "explanation": "The purpose of the Model-View-Controller (MVC) pattern in web applications is to separate data (Model), presentation (View), and business logic (Controller) layers. This separation improves maintainability, scalability, and testability by allowing each layer to be developed and modified independently. The MVC pattern does not replace servlets, manage database transactions, or standardize Java syntax."
    },
    {
        "question": "Which tag library in JSTL is used for XML processing?",
        "options": [
            "Core Tags (c)",
            "Formatting Tags (fmt)",
            "SQL Tags (sql)",
            "XML Tags (x)"
        ],
        "answer": 3,
        "explanation": "The XML Tags (`x`) library in JSTL is specifically designed for processing XML data. It includes tags for parsing, transforming, and extracting data from XML documents, making it ideal for applications that deal with XML-based data. Other libraries, such as Core Tags (`c`) for control flow, Formatting Tags (`fmt`) for internationalization, and SQL Tags (`sql`) for database operations, serve different purposes."
    },
    {
        "question": "What does JSF stand for?",
        "options": [
            "Java Server Framework",
            "Java Servlet Faces",
            "JavaServer Faces",
            "Java Standard Forms"
        ],
        "answer": 2,
        "explanation": "JSF stands for JavaServer Faces. It is a Java-based web application framework designed for building component-based user interfaces. JSF simplifies the development of web applications by providing a set of reusable UI components and managing their state on the server. Other options, like 'Java Server Framework' or 'Java Servlet Faces,' are incorrect terms."
    },
    {
        "question": "What is the primary purpose of JSF?",
        "options": [
            "To manage database transactions",
            "To simplify the development of server-side user interfaces",
            "To provide security for web applications",
            "To handle messaging between services"
        ],
        "answer": 1,
        "explanation": "The primary purpose of JSF (JavaServer Faces) is to simplify the development of server-side user interfaces. It provides a component-based framework for building reusable and dynamic UI elements, along with tools for managing their state and interaction on the server. While JSF can integrate with systems that manage database transactions or provide security, those are not its core functionalities."
    },
    {
        "question": "Which of the following is NOT a feature of JSF?",
        "options": [
            "Server-side validation",
            "Event-driven interaction",
            "Integrated object-relational mapping",
            "Support for internationalization"
        ],
        "answer": 2,
        "explanation": "JSF does not include integrated object-relational mapping (ORM) as a feature. ORM is typically handled by frameworks like Hibernate or JPA. JSF provides features such as server-side validation, event-driven interaction, and support for internationalization, which are essential for building component-based web applications."
    },
    {
        "question": "Which annotation replaces @ManagedBean in JSF for CDI compatibility?",
        "code_snippet": "@... \n@SessionScoped\npublic class MyBean {}",
        "options": [
            "@Named",
            "@Bean",
            "@Inject",
            "@ScopedBean"
        ],
        "answer": 0,
        "explanation": "The `@Named` annotation, provided by Contexts and Dependency Injection (CDI), replaces `@ManagedBean` in JSF for defining managed beans in a CDI-compatible way. It integrates seamlessly with CDI for dependency injection and bean lifecycle management. Other annotations like `@Inject` are used for dependency injection, and `@Bean` or `@ScopedBean` are not valid CDI or JSF annotations."
    },
    {
        "question": "What is the default scope of a JSF managed bean?",
        "options": [
            "@RequestScoped",
            "@SessionScoped",
            "@ViewScoped",
            "@ApplicationScoped"
        ],
        "answer": 0,
        "explanation": "The default scope of a JSF managed bean is `@RequestScoped`. In this scope, the bean is created for a single HTTP request and is discarded once the request is completed. Other scopes, such as `@SessionScoped` or `@ApplicationScoped`, must be explicitly declared and serve different purposes, such as maintaining state across multiple requests or application-wide scope."
    },
    {
        "question": "Which tag is used to define a form in JSF?",
        "code_snippet": "<h: ... >\n    <!-- Input Fields -->\n</h: ... >",
        "options": [
            "<h:input>",
            "<h:form>",
            "<h:output>",
            "<h:command>"
        ],
        "answer": 1,
        "explanation": "The `<h:form>` tag in JSF is used to define a form in the UI. It encapsulates input fields and submits their values to the server when an action is triggered. Other tags, such as `<h:input>`, handle individual input fields, and `<h:output>` or `<h:command>` serve different purposes."
    },
    {
        "question": "What is the purpose of the <f:convertDateTime> tag in JSF?",
        "code_snippet": "<h:outputText value=\"#{bean.date}\">\n    <f:convertDateTime pattern=\"yyyy-MM-dd\"/>\n</h:outputText>",
        "options": [
            "To validate a date input",
            "To convert a date value into a specific string format",
            "To create a custom date picker",
            "To configure the timezone for JSF"
        ],
        "answer": 1,
        "explanation": "The `<f:convertDateTime>` tag in JSF is used to convert a date or time value into a specific string format for display. The `pattern` attribute specifies the desired format, such as `yyyy-MM-dd`. It does not validate date input or configure timezones directly."
    },
    {
        "question": "What does the <h:outputText> tag do in JSF?",
        "options": [
            "Displays static text only",
            "Displays dynamic or static text on the UI",
            "Handles user input",
            "Executes server-side commands"
        ],
        "answer": 1,
        "explanation": "The `<h:outputText>` tag in JSF is used to display static or dynamic text on the user interface. It is often bound to a value expression to show data from the server. It does not handle user input or execute commands."
    },
    {
        "question": "What is the purpose of the navigation rules defined in faces-config.xml?",
        "options": [
            "To manage session lifecycles",
            "To define page transitions based on user actions",
            "To configure bean dependencies",
            "To validate user input across pages"
        ],
        "answer": 1,
        "explanation": "Navigation rules in `faces-config.xml` define page transitions based on user actions. They map outcomes of actions (such as a button click) to specific pages, enabling dynamic navigation. This feature is central to the flow control in JSF applications."
    },
    {
        "question": "What is the purpose of the <h:commandButton> tag in JSF?",
        "code_snippet": "<h:commandButton value=\"Submit\" action=\"submitAction\"/>",
        "options": [
            "To display a clickable link",
            "To create a button that triggers an action or navigation",
            "To handle client-side form validation",
            "To bind a form to a data source"
        ],
        "answer": 1,
        "explanation": "The `<h:commandButton>` tag in JSF is used to create a button that triggers an action or navigation on the server. The `action` attribute specifies the method to be executed when the button is clicked. It is not intended for client-side validation, clickable links, or form binding."
    },
    {
        "question": "What is the purpose of the @ViewScoped annotation in JSF?",
        "options": [
            "To bind a bean to a single HTTP request",
            "To manage a bean's state for the duration of a user session",
            "To manage a bean's state for the lifetime of a view",
            "To share a bean's state across the entire application"
        ],
        "answer": 2,
        "explanation": "The `@ViewScoped` annotation in JSF is used to manage a bean's state for the lifetime of a single view. The bean is created when the view is initialized and remains active until the user navigates away from the view. It is particularly useful for maintaining state across multiple interactions within the same page."
    },
    {
        "question": "True or False: JSF supports both implicit and explicit navigation.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. JSF supports both implicit and explicit navigation. Implicit navigation is achieved through conventions such as matching navigation outcomes to page names, while explicit navigation is defined using navigation rules in `faces-config.xml` or annotations in the managed bean."
    },
    {
        "question": "Which file is used to configure the global settings and navigation rules in JSF?",
        "options": [
            "web.xml",
            "faces-config.xml",
            "beans.xml",
            "application.xml"
        ],
        "answer": 1,
        "explanation": "The `faces-config.xml` file is used to configure global settings and navigation rules in JSF. It allows developers to define navigation flows, managed beans, and other application-level configurations. Other files, such as `web.xml`, are used for broader web application settings but do not specifically manage JSF navigation rules."
    },
    {
        "question": "What is the purpose of the @FacesConverter annotation in JSF?",
        "options": [
            "To declare a custom validator",
            "To define a custom converter for UI components",
            "To bind a bean to a converter",
            "To validate a bean property"
        ],
        "answer": 1,
        "explanation": "The `@FacesConverter` annotation in JSF is used to define a custom converter for UI components. Converters are responsible for converting between UI component values and their corresponding server-side object representations. This annotation simplifies the registration of custom converters for specific types or components."
    },
    {
        "question": "What is the purpose of the lifecycle phases in JSF?",
        "options": [
            "To manage the transaction lifecycle of the database",
            "To define the sequence of steps for processing a request and generating a response",
            "To configure server-side logging for debugging",
            "To manage the deployment of JSF applications"
        ],
        "answer": 1,
        "explanation": "The lifecycle phases in JSF define the sequence of steps for processing a user request and generating a response. These phases include restoring the view, processing events, applying updates, and rendering the response. They ensure that each request is handled systematically and consistently."
    },
    {
        "question": "What does the 'Restore View' phase in the JSF lifecycle do?",
        "options": [
            "Builds the component tree for the requested page",
            "Validates user input",
            "Updates the model values",
            "Renders the final response"
        ],
        "answer": 0,
        "explanation": "The 'Restore View' phase in the JSF lifecycle builds the component tree for the requested page if it is being accessed for the first time. For subsequent requests, it restores the component tree from the server's state. This phase is essential for setting up the page for further processing."
    },
    {
        "question": "What is the difference between a managed bean and a backing bean in JSF?",
        "options": [
            "Managed beans are tied to a specific scope, while backing beans are tied to UI components.",
            "Backing beans are part of the framework, while managed beans are user-defined.",
            "Managed beans handle server-side events, while backing beans handle data conversion.",
            "There is no difference; they are the same."
        ],
        "answer": 0,
        "explanation": "The primary difference between a managed bean and a backing bean in JSF is that managed beans are tied to a specific scope (e.g., request, session, view), while backing beans are specifically associated with a single UI component or page. Backing beans often handle event listeners and UI-specific logic."
    },
    {
        "question": "Which JSF tag is used for displaying error messages related to a specific component?",
        "code_snippet": "<h: ... for=\"inputField\"/>",
        "options": [
            "<h:outputError>",
            "<h:message>",
            "<h:error>",
            "<f:validateMessage>"
        ],
        "answer": 1,
        "explanation": "The `<h:message>` tag in JSF is used to display error messages related to a specific UI component. The `for` attribute specifies the ID of the component for which the message is displayed. This tag provides user-friendly error feedback for validation failures or other issues."
    },
    {
        "question": "Which annotation in JSF indicates that a method is triggered by a user interaction event?",
        "options": [
            "@EventListener",
            "@Action",
            "@FacesAction",
            "@ActionListener"
        ],
        "answer": 3,
        "explanation": "The `@ActionListener` annotation in JSF is used to indicate that a method should be triggered by a user interaction event, such as clicking a button. It is commonly used to bind server-side logic to UI events in a declarative way."
    },
    {
        "question": "What is the role of a render kit in JSF?",
        "options": [
            "To define how UI components are rendered for a specific client",
            "To manage navigation rules for the application",
            "To bind UI components to a database",
            "To handle server-side form validation"
        ],
        "answer": 0,
        "explanation": "A render kit in JSF defines how UI components are rendered for a specific client or output format. For example, the default HTML render kit renders components as HTML, but custom render kits can be created for other formats like PDF or XML."
    },
    {
        "question": "What is a servlet in Java?",
        "options": [
            "A component that handles HTTP requests and responses",
            "A framework for building desktop applications",
            "A type of database connection pool",
            "A utility for managing application configurations"
        ],
        "answer": 0,
        "explanation": "A servlet in Java is a server-side component that handles HTTP requests and responses. It is part of the Java EE platform and is used to build dynamic web applications. Servlets are not frameworks, database connection pools, or configuration utilities."
    },
    {
        "question": "Which class must be extended to create an HTTP servlet?",
        "options": [
            "javax.servlet.Servlet",
            "javax.servlet.http.HttpServlet",
            "java.net.Server",
            "javax.servlet.GenericServlet"
        ],
        "answer": 1,
        "explanation": "To create an HTTP servlet, the `javax.servlet.http.HttpServlet` class must be extended. This class provides methods like `doGet()` and `doPost()` for handling HTTP-specific requests. Other classes like `javax.servlet.GenericServlet` are more generic and lack HTTP-specific functionality."
    },
    {
        "question": "What is the purpose of the `service()` method in a servlet?",
        "options": [
            "To handle lifecycle events like initialization",
            "To handle HTTP requests and generate responses",
            "To manage the database connection pool",
            "To configure the servlet's deployment descriptor"
        ],
        "answer": 1,
        "explanation": "The `service()` method in a servlet is responsible for handling HTTP requests and generating responses. It acts as the entry point for client requests and delegates processing to methods like `doGet()` or `doPost()`. It is not used for lifecycle events, database management, or configuration."
    },
    {
        "question": "What does the following annotation do?",
        "code_snippet": "@WebServlet(name = \"HelloServlet\", urlPatterns = {\"/hello\"})",
        "options": [
            "Maps a servlet to the specified name and URL pattern",
            "Registers a RESTful endpoint",
            "Creates a new servlet instance for every request",
            "Defines a filter for incoming requests"
        ],
        "answer": 0,
        "explanation": "The `@WebServlet` annotation maps a servlet to the specified name and URL pattern. In this case, the servlet is named `HelloServlet` and responds to requests made to `/hello`. It simplifies servlet configuration, which was traditionally done in the `web.xml` file."
    },
    {
        "question": "Which method is used to handle GET requests in a servlet?",
        "options": [
            "doPost()",
            "doGet()",
            "processRequest()",
            "handleGet()"
        ],
        "answer": 1,
        "explanation": "The `doGet()` method is used to handle HTTP GET requests in a servlet. It processes requests where data is typically sent as query parameters in the URL. Other methods like `doPost()` handle POST requests, while `processRequest()` and `handleGet()` are not standard servlet methods."
    },
    {
        "question": "Which HTTP status code is typically returned for a successful response from a servlet?",
        "options": [
            "200",
            "404",
            "500",
            "403"
        ],
        "answer": 0,
        "explanation": "The HTTP status code `200` is returned for a successful response from a servlet. It indicates that the request was received, understood, and processed successfully. Codes like `404` indicate 'Not Found,' `500` indicates a server error, and `403` indicates 'Forbidden.'"
    },
    {
        "question": "What is the purpose of the `doPost()` method in a servlet?",
        "options": [
            "Handles HTTP POST requests",
            "Handles HTTP GET requests",
            "Handles all HTTP methods",
            "Processes initialization events"
        ],
        "answer": 0,
        "explanation": "The `doPost()` method handles HTTP POST requests in a servlet. It is used when data is sent in the body of the request, such as form submissions. `doGet()` handles GET requests, while initialization events are managed by the `init()` method."
    },
    {
        "question": "Which object is used to retrieve request parameters in a servlet?",
        "options": [
            "HttpRequest",
            "HttpServletRequest",
            "RequestManager",
            "RequestHandler"
        ],
        "answer": 1,
        "explanation": "The `HttpServletRequest` object is used to retrieve request parameters in a servlet. It provides methods like `getParameter()` to access form data and query parameters. Other options like `HttpRequest`, `RequestManager`, and `RequestHandler` are not standard servlet objects."
    },
    {
        "question": "What is the difference between a forward and a redirect in servlets?",
        "options": [
            "Forward happens server-side, while redirect is client-side.",
            "Redirect happens server-side, while forward is client-side.",
            "Both forward and redirect are server-side operations.",
            "Both forward and redirect are client-side operations."
        ],
        "answer": 0,
        "explanation": "In servlets, a forward happens on the server-side, where the request is internally passed to another resource (e.g., JSP or servlet) without notifying the client. A redirect, on the other hand, is client-side; the server instructs the browser to make a new request to a different URL."
    },
    {
        "question": "What does the following code do?",
        "code_snippet": "RequestDispatcher dispatcher = request.getRequestDispatcher(\"/success.html\");\ndispatcher.forward(request, response);",
        "options": [
            "Redirects the client to success.html",
            "Forwards the request to success.html within the server",
            "Sends a new request to the client for success.html",
            "Creates a new thread for processing the request"
        ],
        "answer": 1,
        "explanation": "The code forwards the request to `success.html` within the server. The `RequestDispatcher.forward()` method processes the same request and response objects, without the client being aware of the internal forwarding. It does not send a redirect or create a new request."
    },
    {
        "question": "True or False: A servlet instance is created for each HTTP request.",
        "options": [
            "True",
            "False"
        ],
        "answer": 1,
        "explanation": "False. A single servlet instance is typically created and shared for handling multiple requests, unless explicitly configured otherwise. Multiple threads handle concurrent requests to the same servlet instance."
    },
    {
        "question": "Which servlet method is called only once during the servlet lifecycle?",
        "options": [
            "init()",
            "service()",
            "doGet()",
            "destroy()"
        ],
        "answer": 0,
        "explanation": "The `init()` method is called only once during the lifecycle of a servlet, when the servlet is first loaded into memory. It is used for initialization tasks like setting up resources or configurations."
    },
    {
        "question": "What is the role of the `destroy()` method in a servlet?",
        "options": [
            "Handles HTTP DELETE requests",
            "Releases resources before the servlet is destroyed",
            "Initializes the servlet's parameters",
            "Handles exceptions in the servlet lifecycle"
        ],
        "answer": 1,
        "explanation": "The `destroy()` method is called when the servlet is being taken out of service. It is used to release resources like database connections or threads that were allocated during the servlet's lifecycle. It does not handle DELETE requests or initialization."
    },
    {
        "question": "What is the purpose of the `ServletConfig` object?",
        "options": [
            "To store configuration details for the servlet",
            "To manage HTTP sessions",
            "To handle database connections",
            "To define request-scoped attributes"
        ],
        "answer": 0,
        "explanation": "The `ServletConfig` object is used to store configuration details for a servlet. It provides initialization parameters and allows the servlet to access information specific to its deployment. It does not manage HTTP sessions, database connections, or request-scoped attributes."
    },
    {
        "question": "Which annotation is used to define an asynchronous servlet?",
        "options": [
            "@WebServlet",
            "@AsyncServlet",
            "@WebAsync",
            "@AsyncSupported"
        ],
        "answer": 3,
        "explanation": "The `@AsyncSupported` annotation is used to define an asynchronous servlet. It enables the servlet to process requests asynchronously, allowing the server to handle more requests concurrently without blocking threads for long-running tasks."
    },
    {
        "question": "What is the difference between `HttpSession` and `ServletContext`?",
        "options": [
            "`HttpSession` is scoped to a single user session, while `ServletContext` is shared across the entire application.",
            "`HttpSession` is used for server initialization, while `ServletContext` manages request data.",
            "`HttpSession` manages application settings, while `ServletContext` manages user sessions.",
            "Both are used for the same purpose but have different lifetimes."
        ],
        "answer": 0,
        "explanation": "`HttpSession` is scoped to a single user session and stores session-specific data, while `ServletContext` is shared across the entire application and stores application-wide data. These two serve distinct purposes in servlet-based web applications."
    },
    {
        "question": "What is the use of the `getParameter()` method in a servlet?",
        "options": [
            "Retrieves session attributes",
            "Fetches a request parameter by name",
            "Initializes servlet parameters",
            "Sets response headers"
        ],
        "answer": 1,
        "explanation": "The `getParameter()` method in a servlet is used to fetch a request parameter by name. It is commonly used to retrieve form data sent via HTTP GET or POST methods. It does not retrieve session attributes or initialize servlet parameters."
    },
    {
        "question": "Which method is used to send a redirect response to the client?",
        "options": [
            "forward()",
            "sendRedirect()",
            "redirectTo()",
            "dispatch()"
        ],
        "answer": 1,
        "explanation": "The `sendRedirect()` method is used to send a redirect response to the client. It tells the browser to make a new request to a different URL. This is different from `forward()`, which happens server-side without involving the client."
    },
    {
        "question": "What is the purpose of the `getServletContext()` method?",
        "options": [
            "To retrieve request parameters",
            "To access the servlet's configuration details",
            "To obtain context-wide attributes and resources",
            "To initialize HTTP sessions"
        ],
        "answer": 2,
        "explanation": "The `getServletContext()` method is used to obtain context-wide attributes and resources. It provides access to shared data and utilities, such as application initialization parameters, context attributes, and resources like files or data sources."
    },
    {
        "question": "Which HTTP method should be used when submitting sensitive data in a servlet?",
        "options": [
            "GET",
            "POST",
            "HEAD",
            "PUT"
        ],
        "answer": 1,
        "explanation": "The HTTP `POST` method should be used when submitting sensitive data, as it sends data in the request body rather than appending it to the URL. This helps protect sensitive information from being exposed in browser history or logs. The `GET` method is less secure as it includes data in the URL."
    },
    {
        "question": "What does Java EE stand for?",
        "options": [
            "Java Enterprise Edition",
            "Java Enhanced Environment",
            "Java Extended Edition",
            "Java Embedded Edition"
        ],
        "answer": 0,
        "explanation": "Java EE stands for Java Enterprise Edition. It is a set of specifications and APIs for developing enterprise-level applications, such as web services, distributed systems, and scalable web applications."
    },
    {
        "question": "What is the main purpose of Java EE?",
        "options": [
            "To develop lightweight desktop applications",
            "To provide APIs for building scalable, transactional, and secure enterprise applications",
            "To replace relational databases with NoSQL",
            "To manage front-end web interfaces"
        ],
        "answer": 1,
        "explanation": "The main purpose of Java EE is to provide APIs and a runtime environment for building scalable, transactional, and secure enterprise applications. It includes specifications for technologies like servlets, EJB, and JPA, which enable robust back-end systems."
    },
    {
        "question": "Which specification is responsible for dependency injection in Java EE?",
        "options": [
            "EJB",
            "CDI",
            "JPA",
            "JAX-RS"
        ],
        "answer": 1,
        "explanation": "CDI (Contexts and Dependency Injection) is the specification responsible for dependency injection in Java EE. It enables loose coupling between components by managing their lifecycles and injecting dependencies automatically. Other specifications like EJB and JPA serve different purposes."
    },
    {
        "question": "What is the relationship between J2EE, Java EE, and Jakarta EE?",
        "options": [
            "They are completely different frameworks.",
            "Jakarta EE evolved from J2EE and Java EE after being donated to the Eclipse Foundation.",
            "Java EE replaced Jakarta EE for cloud-native applications.",
            "J2EE is the current version of the platform."
        ],
        "answer": 1,
        "explanation": "Jakarta EE evolved from J2EE and Java EE after being donated to the Eclipse Foundation. J2EE was the original name, which was later rebranded as Java EE. After the transfer to the Eclipse Foundation, it was renamed Jakarta EE to signify the transition."
    },
    {
        "question": "Which of the following is NOT a Java EE component?",
        "options": [
            "Servlet",
            "EJB",
            "JMS",
            "Python Script"
        ],
        "answer": 3,
        "explanation": "Python Script is not a Java EE component. Java EE components include technologies such as Servlets, Enterprise JavaBeans (EJB), and Java Message Service (JMS), which are part of the platform for building enterprise-level applications."
    },
    {
        "question": "What is the purpose of the @ApplicationScoped annotation in Java EE?",
        "options": [
            "To specify a bean that is active for a single HTTP request",
            "To define a bean shared across the entire application lifecycle",
            "To manage transactions for a single session",
            "To bind a bean to a REST endpoint"
        ],
        "answer": 1,
        "explanation": "The `@ApplicationScoped` annotation defines a bean that is shared across the entire application lifecycle. It ensures that the same instance of the bean is used throughout the application's runtime, making it suitable for storing global data or configurations."
    },
    {
        "question": "What is a container in Java EE?",
        "options": [
            "A database schema used to manage entities",
            "A runtime environment that provides services to components",
            "A client-side Java application framework",
            "A physical server for deploying Java applications"
        ],
        "answer": 1,
        "explanation": "In Java EE, a container is a runtime environment that provides services such as lifecycle management, security, and transaction handling to components like servlets, EJBs, and RESTful resources. It is not a database schema, client-side framework, or physical server."
    },
    {
        "question": "What is the role of JPA in Java EE?",
        "options": [
            "To manage web services",
            "To handle object-relational mapping and persistence",
            "To provide dependency injection",
            "To manage messaging between components"
        ],
        "answer": 1,
        "explanation": "The Java Persistence API (JPA) in Java EE handles object-relational mapping and persistence. It simplifies the interaction with databases by allowing developers to work with objects instead of SQL, making it a key component for data management."
    },
    {
        "question": "What is the purpose of the Java EE Web Profile?",
        "options": [
            "To support lightweight applications with fewer specifications than the full platform",
            "To enhance client-side frameworks like React or Angular",
            "To replace the Java SE runtime",
            "To provide a graphical interface for developing web applications"
        ],
        "answer": 0,
        "explanation": "The Java EE Web Profile is a subset of the full Java EE platform designed for lightweight web applications. It includes only the necessary specifications for web development, such as Servlets, JSP, and CDI, making it more suitable for smaller, focused applications."
    },
    {
        "question": "Which annotation is used to define a RESTful resource in Java EE?",
        "code_snippet": "@... (\"/resources\")\npublic class MyResource {\n    @GET\n    public String getResource() {\n        return \"Hello, World!\";\n    }\n}",
        "options": [
            "@Service",
            "@WebService",
            "@Path",
            "@Resource"
        ],
        "answer": 2,
        "explanation": "The `@Path` annotation is used to define a RESTful resource in Java EE. It specifies the URI path that the resource will respond to. In this example, the resource is accessible at `/resources`. Other annotations like `@Service` and `@WebService` are used for different purposes."
    },
    {
        "question": "What is the difference between @RequestScoped and @SessionScoped annotations?",
        "options": [
            "@RequestScoped is active for a single HTTP request, while @SessionScoped lasts for the entire user session.",
            "@RequestScoped manages sessions across multiple requests, while @SessionScoped manages single requests.",
            "@RequestScoped is used for persistent data, while @SessionScoped is used for temporary data.",
            "@RequestScoped is for application-level beans, while @SessionScoped is for database connections."
        ],
        "answer": 0,
        "explanation": "The `@RequestScoped` annotation is active for a single HTTP request, meaning the bean is created and destroyed with each request. The `@SessionScoped` annotation, on the other hand, ties the bean to the user session, making it available for the duration of the session."
    },
    {
        "question": "Which of the following is a characteristic of enterprise applications built using Java EE?",
        "options": [
            "Highly scalable and transactional",
            "Limited support for distributed systems",
            "Designed for single-user environments",
            "Does not support RESTful APIs"
        ],
        "answer": 0,
        "explanation": "Enterprise applications built using Java EE are highly scalable and transactional. They are designed to handle distributed systems, support multi-user environments, and provide extensive support for RESTful APIs, making them suitable for large-scale enterprise use."
    },
    {
        "question": "What does the @Stateless annotation in Java EE signify?",
        "options": [
            "The bean maintains client-specific state across multiple method calls.",
            "The bean does not maintain client-specific state.",
            "The bean provides persistence context for transactions.",
            "The bean is tied to a specific HTTP session."
        ],
        "answer": 1,
        "explanation": "The `@Stateless` annotation signifies that the bean does not maintain client-specific state. Stateless beans are typically used for operations that do not depend on user-specific data and are more efficient for handling requests in a stateless manner."
    },
    {
        "question": "What is the purpose of the @Startup annotation in Java EE?",
        "options": [
            "To mark a bean to be initialized when the application starts",
            "To declare a resource for lazy initialization",
            "To define a transactional boundary for a bean",
            "To configure security roles for an application"
        ],
        "answer": 0,
        "explanation": "The `@Startup` annotation is used to mark a bean for eager initialization when the application starts. This is useful for tasks like preloading resources or running initialization logic at startup time."
    },
    {
        "question": "Which of the following is a valid use case for using JTA (Java Transaction API) in Java EE?",
        "options": [
            "To manage distributed transactions across multiple databases",
            "To define RESTful endpoints",
            "To configure application server settings",
            "To synchronize client sessions"
        ],
        "answer": 0,
        "explanation": "JTA (Java Transaction API) is used to manage distributed transactions across multiple databases or other transactional resources. It ensures consistency and reliability in operations that span multiple systems, making it a key feature for enterprise applications."
    },
    {
        "question": "What does the @Inject annotation do in Java EE?",
        "options": [
            "Declares a REST endpoint",
            "Manages web service transactions",
            "Injects dependencies into a bean",
            "Configures the application's database schema"
        ],
        "answer": 2,
        "explanation": "The `@Inject` annotation is used to inject dependencies into a bean. It is part of the CDI (Contexts and Dependency Injection) specification and simplifies the management of object dependencies by letting the container resolve and provide the required instances."
    },
    {
        "question": "What is the purpose of the @PersistenceContext annotation?",
        "code_snippet": "@PersistenceContext\nprivate EntityManager em;",
        "options": [
            "Defines a RESTful resource",
            "Provides access to an EntityManager for database operations",
            "Configures the application's transaction boundaries",
            "Manages messaging queues in the application"
        ],
        "answer": 1,
        "explanation": "The `@PersistenceContext` annotation provides access to an `EntityManager` for database operations. It is commonly used in JPA to interact with the persistence context, enabling tasks like querying, updating, and managing entities."
    },
    {
        "question": "True or False: Java EE applications are always tightly coupled to a specific application server.",
        "options": [
            "True",
            "False"
        ],
        "answer": 1,
        "explanation": "False. Java EE applications are designed to be portable across compliant application servers. This is achieved through standardized APIs and specifications, allowing applications to run on any server that implements the Java EE standard."
    },
    {
        "question": "Which of the following is NOT a method of achieving scalability in Java EE?",
        "options": [
            "Clustering application servers",
            "Adding more nodes horizontally",
            "Using serverless computing frameworks",
            "Increasing server resources vertically"
        ],
        "answer": 2,
        "explanation": "Using serverless computing frameworks is not typically a method of achieving scalability in traditional Java EE applications. Scalability in Java EE is generally achieved through clustering, adding nodes horizontally, or increasing server resources vertically."
    },
    {
        "question": "What is the primary purpose of the CDI specification in Java EE?",
        "options": [
            "To handle asynchronous messaging",
            "To provide type-safe dependency injection and lifecycle management",
            "To configure distributed transactions",
            "To manage database connections"
        ],
        "answer": 1,
        "explanation": "The primary purpose of the CDI (Contexts and Dependency Injection) specification in Java EE is to provide type-safe dependency injection and lifecycle management for beans. It enables loose coupling between components and simplifies their interactions."
    },
    {
        "question": "What is a key principle of data management in Microservices?",
        "options": [
            "All services must share a single database.",
            "Each service should manage its own data.",
            "Data should be synchronized across services in real-time.",
            "All queries should use a central API for consistency."
        ],
        "answer": 1,
        "explanation": "Each service in a microservices architecture should manage its own data. This principle ensures loose coupling between services and allows them to function independently, improving scalability and maintainability."
    },
    {
        "question": "What is the main purpose of using the MicroProfile Config API in data management?",
        "options": [
            "To optimize database queries",
            "To obtain configuration properties from multiple sources",
            "To synchronize databases across services",
            "To handle transactional data updates"
        ],
        "answer": 1,
        "explanation": "The MicroProfile Config API is used to obtain configuration properties from multiple sources, such as environment variables, configuration files, and system properties. It allows applications to manage and access configuration values dynamically without redeploying."
    },
    {
        "question": "What does the CAP theorem state?",
        "options": [
            "A distributed system can only achieve two of the following: consistency, availability, partition tolerance.",
            "A system must prioritize performance, availability, and consistency equally.",
            "Microservices cannot support eventual consistency.",
            "A centralized database is required for consistency and availability."
        ],
        "answer": 0,
        "explanation": "The CAP theorem states that a distributed system can only achieve two of the following three properties simultaneously: consistency, availability, and partition tolerance. This means trade-offs must be made depending on the system's requirements."
    },
    {
        "question": "Which is an example of sacrificing consistency in distributed systems?",
        "options": [
            "Guaranteeing the same data on all nodes",
            "Allowing read and write operations despite network partitions",
            "Ensuring all writes are immediately reflected across nodes",
            "Using synchronized data replication"
        ],
        "answer": 1,
        "explanation": "Allowing read and write operations despite network partitions is an example of sacrificing consistency. This trade-off, often referred to as eventual consistency, prioritizes availability and partition tolerance at the expense of strict data consistency."
    },
    {
        "question": "What is the purpose of the Two-Phase Commit (2PC) protocol?",
        "options": [
            "To improve query performance",
            "To ensure atomic transactions across multiple nodes",
            "To replicate data for scalability",
            "To enable eventual consistency"
        ],
        "answer": 1,
        "explanation": "The Two-Phase Commit (2PC) protocol ensures atomic transactions across multiple nodes in a distributed system. It does this by coordinating transaction commits in two phases to guarantee that either all nodes commit or none do."
    },
    {
        "question": "Which data management pattern ensures data consistency across multiple services without using 2PC?",
        "options": [
            "API Composition",
            "Event Sourcing",
            "Saga Pattern",
            "Database Sharding"
        ],
        "answer": 2,
        "explanation": "The Saga Pattern ensures data consistency across multiple services without using 2PC by breaking transactions into smaller, independent steps. It uses compensating actions to handle failures and maintain eventual consistency in a distributed environment."
    },
    {
        "question": "What is a key characteristic of the Saga Pattern?",
        "options": [
            "It relies on a centralized database for coordination.",
            "It handles distributed transactions using compensating actions.",
            "It requires synchronous communication for consistency.",
            "It guarantees strict ACID compliance."
        ],
        "answer": 1,
        "explanation": "A key characteristic of the Saga Pattern is its use of compensating actions to handle distributed transactions. This pattern avoids strict ACID compliance and centralized databases, enabling eventual consistency in a distributed system through asynchronous communication."
    },
    {
        "question": "What is the difference between compensatable and pivot transactions in the Saga Pattern?",
        "options": [
            "Compensatable transactions cannot be rolled back, while pivot transactions can.",
            "Compensatable transactions can be undone, while pivot transactions determine the success or failure of the saga.",
            "Pivot transactions are asynchronous, while compensatable transactions are synchronous.",
            "Pivot transactions always precede compensatable transactions."
        ],
        "answer": 1,
        "explanation": "Compensatable transactions can be undone using compensating actions, making them reversible. Pivot transactions, however, are the point of no return in the Saga Pattern, determining whether the saga should proceed or fail. Once a pivot transaction succeeds, subsequent compensations are not allowed."
    },
    {
        "question": "What is the main advantage of Event Sourcing in Microservices?",
        "options": [
            "Simplifies schema design for relational databases",
            "Stores application state as a sequence of events for consistency",
            "Improves performance by avoiding ACID transactions",
            "Enables distributed locking mechanisms"
        ],
        "answer": 1,
        "explanation": "Event Sourcing stores application state as a sequence of events, ensuring consistency and a complete history of changes. This approach allows services to rebuild their state from events and enables time-travel debugging and easier integration with event-driven systems."
    },
    {
        "question": "Which is a disadvantage of the shared database approach in Microservices?",
        "options": [
            "Simplified development",
            "Coupling services through a single schema",
            "Reduced performance due to distributed queries",
            "Limited flexibility in choosing database technologies"
        ],
        "answer": 1,
        "explanation": "The shared database approach in Microservices couples services through a single schema, reducing service independence. This tight coupling makes it difficult to evolve individual services and limits scalability and flexibility in database technology choices."
    },
    {
        "question": "What is a key benefit of the database-per-service approach?",
        "options": [
            "Simplified transaction management",
            "Loosely coupled services with independent databases",
            "Centralized database security policies",
            "Guaranteed consistency across services"
        ],
        "answer": 1,
        "explanation": "The database-per-service approach ensures loosely coupled services by allowing each service to have its own independent database. This improves service autonomy, scalability, and the ability to use different database technologies tailored to each service's needs."
    },
    {
        "question": "What is the primary purpose of CQRS (Command Query Responsibility Segregation)?",
        "options": [
            "To separate database connections by roles",
            "To use different data models for reading and writing",
            "To enforce database replication for consistency",
            "To combine API calls across services"
        ],
        "answer": 1,
        "explanation": "CQRS (Command Query Responsibility Segregation) separates data models for reading (queries) and writing (commands), allowing for optimized performance and scalability. This pattern is particularly useful in systems with high read and write demands or complex business logic."
    },
    {
        "question": "Which of the following describes eventual consistency?",
        "options": [
            "All operations are completed within the same transaction.",
            "Data is immediately synchronized across all nodes.",
            "The system ensures data consistency over time, not immediately.",
            "Writes are always consistent, but reads may be stale."
        ],
        "answer": 2,
        "explanation": "Eventual consistency means that the system ensures data consistency over time but does not guarantee immediate consistency. This approach is common in distributed systems, where high availability and partition tolerance are prioritized over strict consistency."
    },
    {
        "question": "What is the main purpose of sharding in Microservices databases?",
        "options": [
            "To improve scalability by distributing data across multiple databases",
            "To synchronize data across nodes in real-time",
            "To enforce strict consistency for all queries",
            "To simplify schema design in relational databases"
        ],
        "answer": 0,
        "explanation": "Sharding improves scalability by distributing data across multiple databases or partitions. Each shard contains a subset of the data, allowing the system to handle larger datasets and higher traffic by distributing the workload among different database instances."
    },
    {
        "question": "What is a challenge of using distributed transactions in Microservices?",
        "options": [
            "Increased latency and communication overhead",
            "Simplified fault tolerance",
            "Reduced need for database replication",
            "Improved query performance across services"
        ],
        "answer": 0,
        "explanation": "Distributed transactions introduce increased latency and communication overhead due to the coordination required between services and databases. This can affect performance and make fault tolerance more complex."
    },
    {
        "question": "True or False: Domain events are often used in conjunction with the Saga Pattern to achieve consistency.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. Domain events are frequently used with the Saga Pattern to achieve eventual consistency. They enable communication between services by notifying them of state changes, helping coordinate compensating actions in case of failures."
    },
    {
        "question": "Which MicroProfile API supports configuration properties for data management?",
        "options": [
            "MicroProfile Metrics",
            "MicroProfile Health",
            "MicroProfile Config",
            "MicroProfile OpenTracing"
        ],
        "answer": 2,
        "explanation": "The MicroProfile Config API supports configuration properties for data management. It allows applications to dynamically retrieve configuration values from various sources, such as environment variables, configuration files, or external configuration servers."
    },
    {
        "question": "What is the purpose of the Read Model in CQRS?",
        "options": [
            "To provide a simplified schema for write operations",
            "To handle complex queries optimized for reads",
            "To manage database transactions",
            "To enforce security policies on data access"
        ],
        "answer": 1,
        "explanation": "The Read Model in CQRS is designed to handle complex queries optimized for read operations. It often uses denormalized data structures to improve query performance and is separate from the Write Model, which focuses on handling commands."
    },
    {
        "question": "What is a common issue with maintaining isolation in distributed systems?",
        "options": [
            "Lost updates and dirty reads",
            "Improved performance with increased latency",
            "Simplified schema migrations",
            "Reduced need for event logging"
        ],
        "answer": 0,
        "explanation": "A common issue with maintaining isolation in distributed systems is the occurrence of lost updates and dirty reads. These problems arise due to the lack of immediate consistency across nodes and the complexities of ensuring transactional integrity in distributed environments."
    },
    {
        "question": "What is a semantic lock in distributed systems?",
        "options": [
            "A database lock used to prevent updates to a row",
            "An application-level flag to prevent conflicts during concurrent updates",
            "A mechanism to increase transaction speed",
            "A method to synchronize data across shards"
        ],
        "answer": 1,
        "explanation": "A semantic lock is an application-level flag used to prevent conflicts during concurrent updates in distributed systems. Unlike database locks, semantic locks operate at the application logic level, offering greater flexibility in managing concurrent operations."
    },
    {
        "question": "What are the three main characteristics of application security?",
        "options": [
            "Authentication, Authorization, Non-repudiation",
            "Authentication, Scalability, Encryption",
            "Integrity, Performance, Monitoring",
            "Authorization, Privacy, Data Replication"
        ],
        "answer": 0,
        "explanation": "The three main characteristics of application security are authentication, authorization, and non-repudiation. Authentication verifies user identity, authorization grants permissions, and non-repudiation ensures actions can be attributed to specific users."
    },
    {
        "question": "What does the authentication process ensure?",
        "options": [
            "Users have permissions to access resources",
            "The user’s identity is verified",
            "The data integrity of the application",
            "The prevention of network attacks"
        ],
        "answer": 1,
        "explanation": "Authentication ensures that the user's identity is verified. It is the first step in securing an application, typically achieved through credentials like usernames and passwords or more advanced methods like biometrics."
    },
    {
        "question": "What is the purpose of the authorization process?",
        "options": [
            "To verify user identity",
            "To grant users access to specific resources",
            "To encrypt data transmitted over a network",
            "To log user activity for auditing"
        ],
        "answer": 1,
        "explanation": "Authorization determines what actions a user is allowed to perform or what resources they can access after their identity has been authenticated. It controls permissions to ensure secure and appropriate use of resources."
    },
    {
        "question": "Which layer is responsible for securing the data while it is being transmitted?",
        "options": [
            "Application Layer",
            "Transport Layer",
            "Message Layer",
            "Session Layer"
        ],
        "answer": 1,
        "explanation": "The Transport Layer is responsible for securing data during transmission. Protocols like TLS (Transport Layer Security) encrypt data to protect it from interception and tampering while in transit."
    },
    {
        "question": "What is a realm in Java EE security?",
        "options": [
            "A security policy domain that defines users, roles, and groups",
            "A database schema for storing user information",
            "A container for managing network requests",
            "A directory for storing application files"
        ],
        "answer": 0,
        "explanation": "A realm in Java EE security is a security policy domain that defines users, roles, and groups. It is used to authenticate and authorize users within the context of an application or server."
    },
    {
        "question": "What does the @RolesAllowed annotation specify?",
        "code_snippet": "@RolesAllowed(\"admin\")\npublic void manageUsers() {\n    // Logic here\n}",
        "options": [
            "Defines the role required to access a resource",
            "Specifies a fallback role for unauthenticated users",
            "Marks the method as requiring secure transmission",
            "Defines the user roles for authentication"
        ],
        "answer": 0,
        "explanation": "The `@RolesAllowed` annotation specifies the role required to access a resource or execute a method. In this example, only users with the 'admin' role are allowed to invoke the `manageUsers` method."
    },
    {
        "question": "What is the function of the @DeclareRoles annotation?",
        "options": [
            "To inject roles into an application",
            "To declare all roles used in the application",
            "To restrict access to specific methods",
            "To configure HTTPS for secure communication"
        ],
        "answer": 1,
        "explanation": "The `@DeclareRoles` annotation is used to declare all roles that are used in the application. This allows the application server to recognize these roles for authentication and authorization purposes."
    },
    {
        "question": "Which authentication mechanism uses HTTP over SSL (HTTPS) for secure communication?",
        "options": [
            "FORM",
            "DIGEST",
            "BASIC",
            "CLIENT-CERT"
        ],
        "answer": 3,
        "explanation": "The `CLIENT-CERT` authentication mechanism uses HTTP over SSL (HTTPS) to provide secure communication. It relies on client certificates for mutual authentication between the client and the server."
    },
    {
        "question": "What does the @PermitAll annotation signify?",
        "options": [
            "Allows access to all users, authenticated or not",
            "Allows access only to administrators",
            "Requires user roles to be declared",
            "Restricts access to all resources"
        ],
        "answer": 0,
        "explanation": "The `@PermitAll` annotation allows access to all users, whether authenticated or not. It is typically used to designate methods or resources that do not require any specific security constraints."
    },
    {
        "question": "True or False: Digest authentication sends the user password over the network in plaintext.",
        "options": [
            "True",
            "False"
        ],
        "answer": 1,
        "explanation": "False. Digest authentication does not send the user's password in plaintext. Instead, it transmits a hashed version of the password combined with a nonce to enhance security."
    },
    {
        "question": "Which XML configuration is used to define authentication mechanisms and security roles?",
        "options": [
            "web.xml",
            "beans.xml",
            "faces-config.xml",
            "security.xml"
        ],
        "answer": 0,
        "explanation": "The `web.xml` file is used to define authentication mechanisms, security constraints, and security roles for a Java EE web application. It serves as the deployment descriptor for configuring web-specific settings."
    },
    {
        "question": "What is the purpose of the SecurityContext in Java EE?",
        "options": [
            "To handle database encryption",
            "To manage user authentication and role-based access",
            "To log security-related events",
            "To configure HTTPS settings"
        ],
        "answer": 1,
        "explanation": "The `SecurityContext` in Java EE is used to manage user authentication and role-based access control. It provides methods to check the user's roles, determine their identity, and enforce security policies programmatically."
    },
    {
        "question": "Which of the following is an example of declarative security?",
        "options": [
            "Using @RolesAllowed annotation",
            "Writing custom login logic in Java",
            "Defining a realm in the server console",
            "Encrypting data manually in the application"
        ],
        "answer": 0,
        "explanation": "Using the `@RolesAllowed` annotation is an example of declarative security. Declarative security involves defining security constraints and roles using annotations or deployment descriptors, rather than writing custom logic programmatically."
    },
    {
        "question": "What is a user group in Java EE security?",
        "options": [
            "A collection of roles assigned to an application",
            "A collection of users sharing common permissions",
            "A database table storing user credentials",
            "A group of APIs for managing authentication"
        ],
        "answer": 1,
        "explanation": "A user group in Java EE security is a collection of users sharing common permissions. Groups are used to assign permissions collectively, simplifying the management of access control for multiple users."
    },
    {
        "question": "Which HTTP status code represents 'Unauthorized'?",
        "options": [
            "403",
            "401",
            "404",
            "500"
        ],
        "answer": 1,
        "explanation": "The HTTP status code `401` represents 'Unauthorized'. It indicates that the client must authenticate itself to access the requested resource. A `403` status, in contrast, means 'Forbidden', where authentication may not resolve the issue."
    },
    {
        "question": "What does the <auth-method>FORM</auth-method> configuration in web.xml define?",
        "options": [
            "Basic authentication",
            "Digest authentication",
            "Form-based login authentication",
            "Certificate-based authentication"
        ],
        "answer": 2,
        "explanation": "The `<auth-method>FORM</auth-method>` configuration in `web.xml` defines form-based login authentication. It allows developers to specify a custom login form and error page for user authentication."
    },
    {
        "question": "Which annotation restricts access to a method for all users?",
        "options": [
            "@RolesAllowed",
            "@DenyAll",
            "@PermitAll",
            "@RestrictAccess"
        ],
        "answer": 1,
        "explanation": "The `@DenyAll` annotation restricts access to a method or resource for all users. It is often used to temporarily block access to a feature or to define stricter access rules programmatically."
    },
    {
        "question": "What is the purpose of the @Liveness annotation in securing Java EE applications?",
        "options": [
            "Checks if a service is running",
            "Authenticates a user during login",
            "Defines user roles for session tracking",
            "Handles encryption during data transfer"
        ],
        "answer": 0,
        "explanation": "The `@Liveness` annotation is used in health checks to determine if a service is running. It is part of application observability rather than user authentication or encryption."
    },
    {
        "question": "True or False: Security constraints defined in web.xml can specify which roles can access specific URL patterns.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. Security constraints in `web.xml` can specify which roles are allowed to access specific URL patterns. This is a common method for managing access control in Java EE web applications."
    },
    {
        "question": "Which of the following best describes programmatic security?",
        "options": [
            "Security defined through application annotations",
            "Security logic written directly into the application code",
            "Security rules defined in deployment descriptors",
            "Security policies enforced by the application server"
        ],
        "answer": 1,
        "explanation": "Programmatic security involves writing security logic directly into the application code. It gives developers full control over security behavior, such as checking user roles or permissions, but requires more effort compared to declarative security."
    },
    {
        "question": "What does JPA stand for?",
        "options": [
            "Java Programming API",
            "Java Persistence API",
            "Java Platform Architecture",
            "Java Process Automation"
        ],
        "answer": 1,
        "explanation": "JPA stands for Java Persistence API. It is a specification for managing relational data in Java applications, providing an object-relational mapping (ORM) framework."
    },
    {
        "question": "What is the primary purpose of JPA?",
        "options": [
            "To manage database transactions",
            "To handle object-relational mapping (ORM)",
            "To configure application servers",
            "To build user interfaces"
        ],
        "answer": 1,
        "explanation": "The primary purpose of JPA is to handle object-relational mapping (ORM). It allows developers to work with database data as Java objects, bridging the gap between object-oriented programming and relational databases."
    },
    {
        "question": "What does the @Entity annotation in JPA signify?",
        "options": [
            "The class is a managed bean",
            "The class is a database entity",
            "The class is a JNDI resource",
            "The class is a transactional object"
        ],
        "answer": 1,
        "explanation": "The `@Entity` annotation in JPA signifies that the class is a database entity. It tells JPA to map the class to a table in the database, enabling it to persist and retrieve data."
    },
    {
        "question": "Which annotation is used to specify the primary key of an entity in JPA?",
        "code_snippet": "@...\nprivate Long id;",
        "options": [
            "@GeneratedValue",
            "@PrimaryKey",
            "@Id",
            "@Key"
        ],
        "answer": 2,
        "explanation": "The `@Id` annotation is used to specify the primary key of an entity in JPA. It marks a field or property as the unique identifier for the entity."
    },
    {
        "question": "What is the purpose of the @Table annotation in JPA?",
        "options": [
            "To specify the table's primary key",
            "To map a class to a specific database table",
            "To create a new table in the database",
            "To define transactional behavior"
        ],
        "answer": 1,
        "explanation": "The `@Table` annotation in JPA is used to map a class to a specific database table. It provides additional mapping details such as the table name and schema."
    },
    {
        "question": "What does the @GeneratedValue annotation in JPA do?",
        "options": [
            "Assigns a default value to a field",
            "Specifies how primary key values are generated",
            "Maps a column to a specific field",
            "Marks a method as a lifecycle callback"
        ],
        "answer": 1,
        "explanation": "The `@GeneratedValue` annotation in JPA specifies how primary key values are generated. It supports strategies like `AUTO`, `IDENTITY`, and `SEQUENCE`, which determine how the database generates unique identifiers for entities."
    },
    {
        "question": "What is the function of the EntityManager in JPA?",
        "options": [
            "Manages database connections",
            "Handles CRUD operations on entities",
            "Configures application-level security",
            "Generates SQL queries automatically"
        ],
        "answer": 1,
        "explanation": "The `EntityManager` in JPA handles CRUD (Create, Read, Update, Delete) operations on entities. It provides methods for persisting, finding, merging, and removing entities, serving as the primary interface for interacting with the persistence context."
    },
    {
        "question": "Which method in the EntityManager is used to save an entity to the database?",
        "options": [
            "persist",
            "merge",
            "save",
            "flush"
        ],
        "answer": 0,
        "explanation": "The `persist` method in the `EntityManager` is used to save a new entity to the database. It marks the entity as managed and ensures its data is inserted into the database when the transaction is committed."
    },
    {
        "question": "What does the @OneToMany annotation define in JPA?",
        "options": [
            "A one-to-one relationship between entities",
            "A many-to-many relationship between entities",
            "A one-to-many relationship between entities",
            "A unidirectional relationship"
        ],
        "answer": 2,
        "explanation": "The `@OneToMany` annotation in JPA defines a one-to-many relationship between entities. It is commonly used when one entity is associated with multiple instances of another entity, such as a parent-child relationship."
    },
    {
        "question": "Which annotation in JPA is used for mapping a composite primary key?",
        "code_snippet": "@... \npublic class EmployeeId implements Serializable {\n    private Long departmentId;\n    private Long employeeNumber;\n}",
        "options": [
            "@CompositeKey",
            "@Embeddable",
            "@CompositePrimaryKey",
            "@KeyGroup"
        ],
        "answer": 1,
        "explanation": "The `@Embeddable` annotation in JPA is used to map a composite primary key. It marks a class as an embeddable type, which can then be used as a composite key in an entity by combining multiple fields."
    },
    {
        "question": "True or False: JPA requires a persistence.xml file to configure the persistence unit.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. JPA requires a `persistence.xml` file to configure the persistence unit. This file specifies details like the database connection, entity classes, and transaction management."
    },
    {
        "question": "What is the purpose of the @ManyToOne annotation in JPA?",
        "options": [
            "To define a many-to-many relationship",
            "To define a unidirectional relationship",
            "To map multiple entities to a single entity",
            "To define a many-to-one relationship between entities"
        ],
        "answer": 3,
        "explanation": "The `@ManyToOne` annotation in JPA is used to define a many-to-one relationship between entities. It indicates that multiple instances of one entity are associated with a single instance of another entity."
    },
    {
        "question": "What is the default fetching strategy for a @OneToMany relationship in JPA?",
        "options": [
            "EAGER",
            "LAZY",
            "IMMEDIATE",
            "FETCH_ALL"
        ],
        "answer": 1,
        "explanation": "The default fetching strategy for a `@OneToMany` relationship in JPA is `LAZY`. This means the related entities are not loaded from the database until they are explicitly accessed."
    },
    {
        "question": "What is the function of the @JoinColumn annotation in JPA?",
        "options": [
            "To specify a column used for joining tables",
            "To define a composite primary key",
            "To map a field to a unique constraint",
            "To set up cascade operations"
        ],
        "answer": 0,
        "explanation": "The `@JoinColumn` annotation in JPA is used to specify the column that joins two tables in a relationship. It defines the foreign key column in the database that maps the relationship between two entities."
    },
    {
        "question": "What is the purpose of the @PrePersist annotation in JPA?",
        "code_snippet": "@PrePersist\npublic void prePersist() {\n    this.createdAt = new Date();\n}",
        "options": [
            "Defines a method to be called after an entity is persisted",
            "Defines a method to be called before an entity is persisted",
            "Defines a method to be called before a query is executed",
            "Defines a method to be called during an update operation"
        ],
        "answer": 1,
        "explanation": "The `@PrePersist` annotation in JPA marks a method to be called before an entity is persisted to the database. It is commonly used for initializing or setting default values, such as timestamps."
    },
    {
        "question": "What is the role of the @CascadeType.ALL setting in JPA?",
        "options": [
            "Applies all available cascade operations to the relationship",
            "Defines a composite primary key",
            "Sets the default fetch type for the relationship",
            "Ensures data is cached for future use"
        ],
        "answer": 0,
        "explanation": "The `CascadeType.ALL` setting in JPA applies all available cascade operations to the relationship, including `PERSIST`, `MERGE`, `REMOVE`, `REFRESH`, and `DETACH`. It ensures that operations performed on a parent entity are cascaded to its related entities."
    },
    {
        "question": "What is the main purpose of JPQL (Java Persistence Query Language)?",
        "options": [
            "To execute raw SQL queries",
            "To query and manipulate entity objects",
            "To define database schemas",
            "To manage transactions"
        ],
        "answer": 1,
        "explanation": "JPQL (Java Persistence Query Language) is used to query and manipulate entity objects in JPA. It provides an object-oriented syntax for interacting with entities, which is independent of the underlying database."
    },
    {
        "question": "Which method in EntityManager is used to synchronize the state of entities with the database?",
        "options": [
            "merge",
            "flush",
            "synchronize",
            "persist"
        ],
        "answer": 1,
        "explanation": "The `flush` method in `EntityManager` is used to synchronize the state of entities with the database. It writes any pending changes in the persistence context to the database but does not commit the transaction."
    },
    {
        "question": "What is the main difference between EAGER and LAZY fetching in JPA?",
        "options": [
            "EAGER fetches data only on demand, while LAZY fetches it immediately.",
            "EAGER fetches data immediately, while LAZY fetches it only on demand.",
            "LAZY is the default fetching strategy, while EAGER must be configured.",
            "EAGER is used for composite keys, while LAZY is used for single keys."
        ],
        "answer": 1,
        "explanation": "EAGER fetching in JPA retrieves data immediately when the parent entity is loaded, while LAZY fetching retrieves data only when it is accessed. LAZY is the default strategy for many-to-one and one-to-many relationships."
    },
    {
        "question": "True or False: JPA allows polymorphic queries using the inheritance hierarchy of entities.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. JPA supports polymorphic queries, allowing developers to query entities based on their inheritance hierarchy. For example, querying a parent entity class will also return instances of its subclasses."
    },
    {
        "question": "What is the main purpose of the Microservices architecture?",
        "options": [
            "To build monolithic systems",
            "To break down applications into small, independently managed services",
            "To reduce the need for APIs in applications",
            "To standardize database schemas"
        ],
        "answer": 1,
        "explanation": "The main purpose of the Microservices architecture is to break down applications into small, independently managed services. This approach enhances scalability, maintainability, and the ability to develop and deploy features independently."
    },
        {
        "question": "Which of the following is NOT a characteristic of Microservices?",
        "options": [
            "Small and isolated services",
            "Each service has a single responsibility",
            "Each service shares a common database",
            "Services expose standard interfaces"
        ],
        "answer": 2,
        "explanation": "In Microservices architecture, each service typically has its own database to ensure loose coupling and independent scalability. Sharing a common database contradicts this principle and introduces tight coupling between services."
    },
    {
        "question": "What are the benefits of using Microservices architecture?",
        "options": [
            "Flexibility and scalability",
            "Centralized deployment",
            "Tightly coupled services",
            "Standardized programming language"
        ],
        "answer": 0,
        "explanation": "Microservices architecture offers flexibility and scalability by breaking down applications into smaller, independently deployable services. This allows teams to work on different services simultaneously and scale only the required components."
    },
    {
        "question": "What is the primary communication protocol used in Microservices?",
        "options": [
            "SOAP",
            "FTP",
            "REST",
            "SMTP"
        ],
        "answer": 2,
        "explanation": "REST is the primary communication protocol used in Microservices due to its simplicity, lightweight nature, and support for standard HTTP methods. While SOAP is another option, it is less commonly used in modern Microservices."
    },
    {
        "question": "What does Eclipse MicroProfile provide?",
        "options": [
            "A complete replacement for Java EE",
            "Optimized APIs and technologies for building Microservices",
            "A graphical interface for Java EE development",
            "A deployment platform for serverless applications"
        ],
        "answer": 1,
        "explanation": "Eclipse MicroProfile provides optimized APIs and technologies for building Microservices. It extends Java EE with features like configuration management, health checks, and fault tolerance, specifically tailored for Microservices architecture."
    },
    {
        "question": "Which of the following is a runtime supporting Eclipse MicroProfile?",
        "options": [
            "Spring Boot",
            "WildFly",
            "Django",
            "Node.js"
        ],
        "answer": 1,
        "explanation": "WildFly is a runtime that supports Eclipse MicroProfile, enabling developers to build and deploy Microservices. Other runtimes like Payara Micro and Open Liberty also support MicroProfile. Spring Boot and Node.js are not MicroProfile runtimes."
    },
    {
        "question": "What does the @ApplicationPath annotation do in a MicroProfile application?",
        "code_snippet": "@ApplicationPath(\"/api\")\npublic class AppConfig extends Application {}",
        "options": [
            "Defines the default HTTP method for services",
            "Sets the base URI for all REST endpoints",
            "Registers custom configuration properties",
            "Specifies the scope of application beans"
        ],
        "answer": 1,
        "explanation": "The `@ApplicationPath` annotation sets the base URI for all REST endpoints in a MicroProfile application. In this example, all endpoints would be prefixed with `/api`."
    },
    {
        "question": "What is the purpose of the MicroProfile Config API?",
        "options": [
            "To define database schemas for Microservices",
            "To manage configuration properties across different environments",
            "To handle asynchronous processing in Microservices",
            "To provide a centralized logging system"
        ],
        "answer": 1,
        "explanation": "The MicroProfile Config API manages configuration properties across different environments. It enables applications to retrieve configuration values dynamically from multiple sources, such as environment variables, property files, and external configuration servers."
    },
    {
        "question": "Which MicroProfile API provides a unified way to expose metrics in Microservices?",
        "options": [
            "MicroProfile Health",
            "MicroProfile Metrics",
            "MicroProfile Config",
            "MicroProfile OpenTracing"
        ],
        "answer": 1,
        "explanation": "The MicroProfile Metrics API provides a unified way to expose metrics in Microservices. It allows developers to collect and expose application telemetry, such as counters, timers, and gauges, to monitor performance and resource usage."
    },
    {
        "question": "What is the main benefit of MicroProfile Fault Tolerance?",
        "options": [
            "It allows services to handle failures gracefully.",
            "It provides high-performance logging.",
            "It reduces the need for testing Microservices.",
            "It ensures all services are synchronous."
        ],
        "answer": 0,
        "explanation": "The main benefit of MicroProfile Fault Tolerance is that it allows services to handle failures gracefully. It provides features like retries, timeouts, circuit breakers, and bulkheads to ensure resilience in distributed systems."
    },
    {
        "question": "Which annotation is used to implement a circuit breaker in MicroProfile Fault Tolerance?",
        "code_snippet": "@... (successThreshold = 5, requestVolumeThreshold = 10, failureRatio = 0.5, delay = 1000)\npublic String getData() {\n    return \"Success\";\n}",
        "options": [
            "@Bulkhead",
            "@Timeout",
            "@Retry",
            "@CircuitBreaker"
        ],
        "answer": 3,
        "explanation": "The `@CircuitBreaker` annotation in MicroProfile Fault Tolerance is used to implement the circuit breaker pattern. It prevents a service from being overwhelmed by failures by opening the circuit after a specified failure ratio is exceeded."
    },
    {
        "question": "What is the purpose of the @Retry annotation in MicroProfile Fault Tolerance?",
        "options": [
            "To specify the retry logic for failed operations",
            "To define the timeout for a method",
            "To declare a fallback method",
            "To limit the concurrent requests to a service"
        ],
        "answer": 0,
        "explanation": "The `@Retry` annotation specifies the retry logic for failed operations in MicroProfile Fault Tolerance. It allows methods to automatically retry execution based on configurable parameters like maximum retries and delay."
    },
    {
        "question": "Which annotation is used to limit concurrent access to a Microservice?",
        "code_snippet": "@... (value = 5, waitingTaskQueue = 10)\npublic String processData() {\n    return \"Processed\";\n}",
        "options": [
            "@Timeout",
            "@Bulkhead",
            "@Retry",
            "@CircuitBreaker"
        ],
        "answer": 1,
        "explanation": "The `@Bulkhead` annotation in MicroProfile Fault Tolerance is used to limit concurrent access to a Microservice. It ensures that a service can handle only a specific number of concurrent requests, protecting it from overload."
    },
    {
        "question": "What is the role of @Liveness in MicroProfile Health?",
        "options": [
            "Checks if the application is ready to handle requests",
            "Monitors the availability of external services",
            "Indicates whether the application is running",
            "Ensures that the application has no critical errors"
        ],
        "answer": 2,
        "explanation": "The `@Liveness` annotation in MicroProfile Health indicates whether the application is running. It is used to expose health check endpoints that signal the system's operational status to monitoring tools."
    },
    {
        "question": "What is the primary purpose of MicroProfile OpenAPI?",
        "options": [
            "To provide distributed tracing for services",
            "To simplify the implementation of asynchronous services",
            "To generate documentation for RESTful APIs",
            "To manage security for REST endpoints"
        ],
        "answer": 2,
        "explanation": "The primary purpose of MicroProfile OpenAPI is to generate documentation for RESTful APIs. It helps developers create standardized API specifications, enabling better understanding and integration of services."
    },
    {
        "question": "True or False: The MicroProfile Metrics API can provide custom telemetry data for Microservices.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. The MicroProfile Metrics API allows developers to define custom telemetry data for Microservices, such as counters, timers, and custom metrics, to monitor application performance and resource usage effectively."
    },
    {
        "question": "What is a common communication challenge in Microservices architectures?",
        "options": [
            "All services must use the same programming language.",
            "Services require tightly coupled configurations.",
            "Communication overhead and service discovery.",
            "Services are not allowed to scale independently."
        ],
        "answer": 2,
        "explanation": "A common communication challenge in Microservices architectures is the overhead caused by inter-service communication and the complexity of service discovery. These challenges arise due to the distributed nature of Microservices, which rely on APIs or messaging systems for communication."
    },
    {
        "question": "Which of the following describes the concept of eventual consistency in distributed systems?",
        "options": [
            "All requests will return consistent results immediately.",
            "Data updates may be delayed but will eventually synchronize.",
            "Consistency is maintained only for read operations.",
            "Data updates must be applied synchronously across all nodes."
        ],
        "answer": 1,
        "explanation": "Eventual consistency means that data updates may be delayed but will eventually synchronize across all nodes. It is a common trade-off in distributed systems to achieve availability and partition tolerance."
    },
    {
        "question": "What is the purpose of the CompletionStage API in Microservices?",
        "options": [
            "To manage synchronous calls between services",
            "To enable asynchronous chaining of operations",
            "To handle retries for failed operations",
            "To define service-level agreements"
        ],
        "answer": 1,
        "explanation": "The CompletionStage API enables asynchronous chaining of operations. It provides a way to compose multiple asynchronous tasks and manage their execution without blocking, making it ideal for improving performance in Microservices."
    },
    {
        "question": "What is the main purpose of the @Timeout annotation in MicroProfile Fault Tolerance?",
        "options": [
            "To set a time limit for method execution",
            "To define fallback logic for failures",
            "To restrict concurrent service access",
            "To create retry policies for slow services"
        ],
        "answer": 0,
        "explanation": "The `@Timeout` annotation sets a time limit for method execution. If a method exceeds the specified timeout, it is interrupted to prevent it from blocking the system or consuming resources unnecessarily."
    },
    {
        "question": "What does CDI stand for in Java EE?",
        "options": [
            "Context and Dependency Injection",
            "Component Development Interface",
            "Code and Data Integration",
            "Container Dependency Implementation"
        ],
        "answer": 0,
        "explanation": "CDI stands for Context and Dependency Injection. It is a specification in Java EE that provides a framework for type-safe dependency injection and lifecycle management of beans."
    },
    {
        "question": "What is the primary purpose of CDI in Java EE?",
        "options": [
            "To handle HTTP requests and responses",
            "To provide type-safe dependency injection and interception",
            "To manage database transactions",
            "To replace Entity Beans in persistence management"
        ],
        "answer": 1,
        "explanation": "The primary purpose of CDI is to provide type-safe dependency injection and interception. It simplifies the development of loosely coupled components by managing their lifecycle and interactions."
    },
    {
        "question": "Which annotation is used to declare a CDI-managed bean?",
        "code_snippet": "@... \n@RequestScoped\npublic class MyBean {\n    public String sayHello() {\n        return \"Hello!\";\n    }\n}",
        "options": [
            "@Component",
            "@Bean",
            "@Named",
            "@ManagedBean"
        ],
        "answer": 2,
        "explanation": "The `@Named` annotation is used to declare a CDI-managed bean. It allows the bean to be accessible by its name in expression language (EL) contexts, enabling its use in JSF or other frameworks."
    },
    {
        "question": "What is the default scope for a CDI bean if no scope is specified?",
        "options": [
            "@ApplicationScoped",
            "@RequestScoped",
            "@Dependent",
            "@SessionScoped"
        ],
        "answer": 2,
        "explanation": "The default scope for a CDI bean is `@Dependent`. This means the bean's lifecycle is tied to the object that injects it, making it a dependent object with no standalone lifecycle."
    },
    {
        "question": "What is the purpose of the @Inject annotation in CDI?",
        "options": [
            "To inject dependencies into a bean",
            "To initialize a bean",
            "To register a bean in the container",
            "To declare the scope of a bean"
        ],
        "answer": 0,
        "explanation": "The `@Inject` annotation is used to inject dependencies into a CDI-managed bean. It allows the container to resolve and provide the required instances automatically."
    },
    {
        "question": "Which of the following is NOT a scope provided by CDI?",
        "options": [
            "@RequestScoped",
            "@SessionScoped",
            "@ViewScoped",
            "@ThreadScoped"
        ],
        "answer": 3,
        "explanation": "`@ThreadScoped` is not a scope provided by CDI. CDI includes scopes like `@RequestScoped`, `@SessionScoped`, `@ApplicationScoped`, and `@ViewScoped`, which are used to manage the lifecycle of beans in various contexts."
    },
    {
        "question": "What is the role of the @Qualifier annotation in CDI?",
        "options": [
            "To specify the scope of a bean",
            "To resolve ambiguity when multiple beans match a dependency",
            "To inject a bean using its name",
            "To define lifecycle callbacks for a bean"
        ],
        "answer": 1,
        "explanation": "The `@Qualifier` annotation is used in CDI to resolve ambiguity when multiple beans match a dependency. It allows developers to specify which bean should be injected by associating the dependency with a qualifier."
    },
    {
        "question": "True or False: CDI beans can only be injected into other CDI beans.",
        "options": [
            "True",
            "False"
        ],
        "answer": 1,
        "explanation": "False. CDI beans can be injected into various components, including servlets, RESTful endpoints, and other Java EE components, not just other CDI beans."
    },
    {
        "question": "What is the purpose of the @Produces annotation in CDI?",
        "options": [
            "To mark a method as a factory for creating injectable objects",
            "To define the scope of a bean",
            "To declare a bean as injectable",
            "To register a bean in the container"
        ],
        "answer": 0,
        "explanation": "The `@Produces` annotation in CDI marks a method as a factory for creating injectable objects. It is used when the object cannot be directly instantiated or requires special initialization logic."
    },
    {
        "question": "Which of the following annotations can be used to create a custom qualifier in CDI?",
        "code_snippet": "@... \n@Retention(RUNTIME)\n@Target({FIELD, TYPE, METHOD})\npublic @interface CustomQualifier {}",
        "options": [
            "@Inject",
            "@Qualifier",
            "@Named",
            "@Scoped"
        ],
        "answer": 1,
        "explanation": "The `@Qualifier` annotation is used to create a custom qualifier in CDI. Qualifiers are used to distinguish between multiple beans of the same type when resolving dependencies."
    },
    {
        "question": "Which annotation specifies that a bean is application-wide and shared across all users?",
        "options": [
            "@RequestScoped",
            "@SessionScoped",
            "@ApplicationScoped",
            "@Dependent"
        ],
        "answer": 2,
        "explanation": "The `@ApplicationScoped` annotation specifies that a bean is application-wide and shared across all users. It is active for the entire lifecycle of the application."
    },
    {
        "question": "What is the purpose of the @Alternative annotation in CDI?",
        "options": [
            "To define a fallback bean if the primary bean fails",
            "To specify a bean that can be selected at deployment time",
            "To inject multiple beans into a single dependency",
            "To declare a bean as thread-safe"
        ],
        "answer": 1,
        "explanation": "The `@Alternative` annotation specifies a bean that can be selected at deployment time. It allows developers to configure which implementation should be used without modifying the code."
    },
    {
        "question": "What does the @ConversationScoped annotation in CDI do?",
        "options": [
            "Limits the scope to a single HTTP request",
            "Maintains the bean's state for a user session",
            "Keeps the bean active for the duration of a user-defined conversation",
            "Shares the bean across the entire application"
        ],
        "answer": 2,
        "explanation": "The `@ConversationScoped` annotation keeps the bean active for the duration of a user-defined conversation. This scope is useful for maintaining state across multiple requests within a specific context."
    },
    {
        "question": "Which CDI annotation is used to implement event-based communication between components?",
        "options": [
            "@Event",
            "@Inject",
            "@Observe",
            "@Produces"
        ],
        "answer": 2,
        "explanation": "The `@Observe` annotation in CDI is used to implement event-based communication. It allows a method to listen for and respond to events triggered by components annotated with `@Event`."
    },
    {
        "question": "What is the purpose of the @Interceptor annotation in CDI?",
        "options": [
            "To inject dependencies into beans",
            "To define interceptors for cross-cutting concerns",
            "To register a bean in the container",
            "To scope a bean for the entire application"
        ],
        "answer": 1,
        "explanation": "The `@Interceptor` annotation is used to define interceptors for cross-cutting concerns, such as logging, security, or transactions. Interceptors allow the execution of additional logic before or after business method invocations."
    },
    {
        "question": "Which file is used to configure CDI deployment descriptors?",
        "options": [
            "beans.xml",
            "web.xml",
            "faces-config.xml",
            "persistence.xml"
        ],
        "answer": 0,
        "explanation": "The `beans.xml` file is used to configure CDI deployment descriptors. It is required to enable CDI and allows for the declaration of beans, interceptors, decorators, and alternatives."
    },
    {
        "question": "What is the lifecycle of a bean with the @RequestScoped annotation?",
        "options": [
            "It lasts for the lifetime of the application.",
            "It lasts for the duration of an HTTP request.",
            "It lasts for the duration of a user session.",
            "It lasts indefinitely until explicitly destroyed."
        ],
        "answer": 1,
        "explanation": "A bean with the `@RequestScoped` annotation lasts for the duration of an HTTP request. It is created when the request starts and destroyed when the request ends."
    },
    {
        "question": "Which annotation is used to bind a bean to an EL (Expression Language) name?",
        "code_snippet": "@...(\"myBean\")\n@RequestScoped\npublic class MyBean {}",
        "options": [
            "@Named",
            "@ELName",
            "@Scoped",
            "@Context"
        ],
        "answer": 0,
        "explanation": "The `@Named` annotation binds a bean to an EL (Expression Language) name. In this example, the bean can be accessed using the name `myBean` in JSF or other EL-compatible frameworks."
    },
    {
        "question": "Which CDI scope is specifically designed for use with JSF pages?",
        "options": [
            "@RequestScoped",
            "@SessionScoped",
            "@ViewScoped",
            "@ApplicationScoped"
        ],
        "answer": 2,
        "explanation": "The `@ViewScoped` annotation is specifically designed for use with JSF pages. It keeps the bean active as long as the user interacts with the same view, making it ideal for maintaining state across multiple requests within the same page."
    },
    {
        "question": "True or False: The CDI container manages the lifecycle of all managed beans, including their initialization and destruction.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. The CDI container manages the lifecycle of all managed beans, including their initialization, dependency injection, and destruction. This simplifies application development and ensures proper resource management."
    },
    {
        "question": "What does SOA stand for?",
        "options": [
            "Service-Oriented Architecture",
            "System-Oriented Application",
            "Service-Oriented Application",
            "System-On-Architecture"
        ],
        "answer": 0,
        "explanation": "SOA stands for Service-Oriented Architecture. It is an architectural pattern that structures applications as a collection of services, each providing a specific functionality through defined interfaces."
    },
    {
        "question": "What is the primary purpose of Service-Oriented Architecture (SOA)?",
        "options": [
            "To create monolithic systems",
            "To organize and utilize distributed capabilities",
            "To centralize database management",
            "To eliminate network-based services"
        ],
        "answer": 1,
        "explanation": "The primary purpose of Service-Oriented Architecture (SOA) is to organize and utilize distributed capabilities. SOA allows systems to communicate and work together through well-defined services, enabling modularity and scalability."
    },
    {
        "question": "Which of the following is NOT an example of a distributed system implementation?",
        "options": [
            "CORBA",
            "Java RMI",
            "WCF",
            "HTML5"
        ],
        "answer": 3,
        "explanation": "HTML5 is not an example of a distributed system implementation. CORBA, Java RMI, and WCF are frameworks and technologies used to implement distributed systems, while HTML5 is a markup language used for structuring web content."
    },
    {
        "question": "What is the main benefit of Web Services in SOA?",
        "options": [
            "They are technology-independent and platform-agnostic.",
            "They require only Java for implementation.",
            "They cannot be combined to achieve complex operations.",
            "They do not support interoperability."
        ],
        "answer": 0,
        "explanation": "The main benefit of Web Services in SOA is their technology independence and platform agnosticism. They enable interoperability by using standard protocols like HTTP, SOAP, and REST, allowing different systems to communicate seamlessly."
    },
    {
        "question": "Which protocol is commonly used in Web Services for message exchange?",
        "options": [
            "SOAP",
            "TCP",
            "FTP",
            "SMTP"
        ],
        "answer": 0,
        "explanation": "SOAP (Simple Object Access Protocol) is a commonly used protocol in Web Services for exchanging structured information in a decentralized, distributed environment."
    },
    {
        "question": "What does WSDL stand for?",
        "options": [
            "Web Services Data Language",
            "Web Services Description Language",
            "Web Standard Descriptor Language",
            "Web Services Deployment Language"
        ],
        "answer": 1,
        "explanation": "WSDL stands for Web Services Description Language. It is an XML-based language used to describe the functionality of a web service, including its operations, input/output messages, and endpoints."
    },
    {
        "question": "Which of the following is a feature of RESTful Web Services?",
        "options": [
            "Based on XML protocols",
            "Supports loose coupling via standard HTTP methods",
            "Relies on UDDI for service discovery",
            "Uses SOAP as the main transport protocol"
        ],
        "answer": 1,
        "explanation": "A key feature of RESTful Web Services is their support for loose coupling via standard HTTP methods like GET, POST, PUT, and DELETE. They are not limited to XML and can use other formats like JSON, unlike SOAP-based services."
    },
    {
        "question": "Which annotation is used to mark a Java class as a JAX-WS Web Service?",
        "code_snippet": "@... \npublic class MyService {\n    public String sayHello(String name) {\n        return \"Hello, \" + name;\n    }\n}",
        "options": [
            "@Service",
            "@Endpoint",
            "@WebService",
            "@WSService"
        ],
        "answer": 2,
        "explanation": "The `@WebService` annotation is used to mark a Java class as a JAX-WS Web Service. It specifies that the class contains methods that can be exposed as web service operations."
    },
    {
        "question": "Which annotation marks a method inside a Web Service class to be exposed as a web operation?",
        "code_snippet": "@... \npublic String sayHello(String name) {\n    return \"Hello, \" + name;\n}",
        "options": [
            "@Operation",
            "@WebMethod",
            "@ServiceMethod",
            "@WSOperation"
        ],
        "answer": 1,
        "explanation": "The `@WebMethod` annotation marks a method inside a Web Service class to be exposed as a web operation. It makes the method accessible to clients using the web service."
    },
    {
        "question": "What is the primary function of the UDDI in SOA?",
        "options": [
            "To store user credentials",
            "To provide a directory for locating Web Services",
            "To validate XML documents",
            "To monitor Web Service traffic"
        ],
        "answer": 1,
        "explanation": "The primary function of UDDI (Universal Description, Discovery, and Integration) in SOA is to provide a directory for locating Web Services. It allows services to be registered, discovered, and used by other systems."
    },
    {
        "question": "What type of Web Service uses the JAX-RS API?",
        "options": [
            "SOAP-based Web Services",
            "RESTful Web Services",
            "CORBA-based Web Services",
            "RPC-based Web Services"
        ],
        "answer": 1,
        "explanation": "The JAX-RS API is used to develop RESTful Web Services. It simplifies the creation of REST endpoints by providing annotations for HTTP methods and URI mappings."
    },
    {
        "question": "Which HTTP method is commonly used to retrieve data from a RESTful Web Service?",
        "options": [
            "POST",
            "PUT",
            "DELETE",
            "GET"
        ],
        "answer": 3,
        "explanation": "The HTTP GET method is commonly used to retrieve data from a RESTful Web Service. It is a read-only operation and does not modify the resource on the server."
    },
    {
        "question": "What is the purpose of the @Path annotation in JAX-RS?",
        "code_snippet": "@Path(\"/hello\")\npublic class HelloResource {\n    @GET\n    public String sayHello() {\n        return \"Hello, World!\";\n    }\n}",
        "options": [
            "Defines the HTTP method to be used",
            "Specifies the URI path to the resource",
            "Defines the input parameters of the method",
            "Marks the method as a web operation"
        ],
        "answer": 1,
        "explanation": "The `@Path` annotation in JAX-RS specifies the URI path to the resource. In this example, the resource is accessible at `/hello`."
    },
    {
        "question": "What does the @Produces annotation specify in a RESTful Web Service?",
        "options": [
            "The MIME types the method can consume",
            "The MIME types the method can produce",
            "The URI path for the resource",
            "The format of the HTTP response header"
        ],
        "answer": 1,
        "explanation": "The `@Produces` annotation specifies the MIME types that the method can produce as part of its response. For example, it can indicate that the method returns data in JSON or XML format."
    },
    {
        "question": "Which HTTP status code is returned for a successful GET request?",
        "options": [
            "404",
            "200",
            "500",
            "403"
        ],
        "answer": 1,
        "explanation": "The HTTP status code `200` indicates a successful GET request. It means the server successfully returned the requested data."
    },
    {
        "question": "What is the main advantage of using RESTful Web Services over SOAP-based Web Services?",
        "options": [
            "RESTful Web Services are more rigid in structure.",
            "RESTful Web Services are easier to use and require less overhead.",
            "SOAP-based Web Services are faster.",
            "SOAP-based Web Services are more extensible."
        ],
        "answer": 1,
        "explanation": "RESTful Web Services are easier to use and require less overhead compared to SOAP-based Web Services. They leverage standard HTTP methods and formats like JSON, making them lightweight and simpler to implement."
    },
    {
        "question": "What does the @GET annotation in JAX-RS signify?",
        "options": [
            "The method accepts HTTP POST requests.",
            "The method processes HTTP GET requests.",
            "The method deletes a resource.",
            "The method processes HTTP PUT requests."
        ],
        "answer": 1,
        "explanation": "The `@GET` annotation in JAX-RS signifies that the method processes HTTP GET requests. It is typically used to retrieve data from a resource."
    },
    {
        "question": "Which annotation is used to specify the content type of a request body in a RESTful Web Service?",
        "options": [
            "@Consumes",
            "@Produces",
            "@Path",
            "@RequestBody"
        ],
        "answer": 0,
        "explanation": "The `@Consumes` annotation specifies the content types that a method can accept in the request body. For example, it can declare that the method accepts data in JSON or XML format."
    },
    {
        "question": "What is the purpose of the @ApplicationPath annotation in a JAX-RS application?",
        "code_snippet": "@ApplicationPath(\"/api\")\npublic class AppConfig extends Application {}",
        "options": [
            "Specifies the default HTTP method for the application",
            "Defines the base URI for all resources in the application",
            "Registers all the classes in the application",
            "Defines the MIME types supported by the application"
        ],
        "answer": 1,
        "explanation": "The `@ApplicationPath` annotation defines the base URI for all resources in a JAX-RS application. In this example, all endpoints would be prefixed with `/api`."
    },
    {
        "question": "True or False: RESTful Web Services require a WSDL document for service description.",
        "options": [
            "True",
            "False"
        ],
        "answer": 1,
        "explanation": "False. RESTful Web Services do not require a WSDL document for service description. Instead, they use lightweight documentation standards like OpenAPI for describing APIs."
    },
    {
        "question": "What does JNDI stand for?",
        "options": [
            "Java Naming and Directory Interface",
            "Java Network and Data Integration",
            "Java Node Data Integration",
            "Java Name Descriptor Integration"
        ],
        "answer": 0,
        "explanation": "JNDI stands for Java Naming and Directory Interface. It is a Java API for accessing naming and directory services to locate and use resources in an application."
    },
    {
        "question": "What is the primary purpose of JNDI in Java applications?",
        "options": [
            "To configure the presentation layer",
            "To provide a standard way to locate and access resources",
            "To enable client-side scripting",
            "To handle multithreading in web applications"
        ],
        "answer": 1,
        "explanation": "The primary purpose of JNDI is to provide a standard way to locate and access resources, such as databases, EJBs, and configuration parameters, in a Java application."
    },
    {
        "question": "Which of the following is NOT an example of a naming service?",
        "options": [
            "DNS",
            "RMI Registry",
            "LDAP",
            "JDBC Driver"
        ],
        "answer": 3,
        "explanation": "A JDBC Driver is not a naming service. Naming services like DNS, RMI Registry, and LDAP provide mechanisms for associating names with objects or resources."
    },
    {
        "question": "What is the term used in JNDI for associating a name with an object?",
        "options": [
            "Mapping",
            "Binding",
            "Contextualizing",
            "Referencing"
        ],
        "answer": 1,
        "explanation": "In JNDI, the term 'binding' is used to describe the association of a name with an object in a naming or directory service."
    },
    {
        "question": "What is a context in JNDI?",
        "options": [
            "A connection pool for database connections",
            "A set of name-to-object bindings using a specific naming convention",
            "A thread-safe environment for running Java applications",
            "A hierarchical structure for managing session data"
        ],
        "answer": 1,
        "explanation": "In JNDI, a context represents a set of name-to-object bindings using a specific naming convention. It provides methods to bind, lookup, and manage resources."
    },
    {
        "question": "Which JNDI operation is used to retrieve an object by its name?",
        "options": [
            "bind",
            "lookup",
            "list",
            "rebind"
        ],
        "answer": 1,
        "explanation": "The `lookup` operation in JNDI is used to retrieve an object by its name. It allows applications to locate resources such as DataSources or EJBs."
    },
    {
        "question": "What does the following code snippet do?",
        "code_snippet": "Context ctx = new InitialContext();\nDataSource ds = (DataSource) ctx.lookup(\"jdbc/myDataSource\");",
        "options": [
            "Creates a new JDBC DataSource",
            "Binds a DataSource to the JNDI context",
            "Looks up a DataSource object by its JNDI name",
            "Deletes a DataSource from the JNDI context"
        ],
        "answer": 2,
        "explanation": "The code snippet looks up a `DataSource` object by its JNDI name (`jdbc/myDataSource`). The `lookup` method retrieves the DataSource registered under the specified name."
    },
    {
        "question": "Which JNDI annotation can be used to inject a DataSource directly into a Java class?",
        "code_snippet": "@...(name=\"jdbc/sample\")\nprivate DataSource ds;",
        "options": [
            "@JNDI",
            "@Inject",
            "@Resource",
            "@DataSource"
        ],
        "answer": 2,
        "explanation": "The `@Resource` annotation is used to inject a `DataSource` directly into a Java class. It simplifies accessing resources defined in the application server."
    },
    {
        "question": "What does the javax.sql.DataSource interface represent?",
        "options": [
            "A pool of active threads",
            "A factory for database connections",
            "A naming service implementation",
            "A data serialization framework"
        ],
        "answer": 1,
        "explanation": "The `javax.sql.DataSource` interface represents a factory for database connections. It abstracts the details of connecting to a database and can include connection pooling."
    },
    {
        "question": "Which method in JNDI is used to associate a new name with an object?",
        "options": [
            "rebind",
            "bind",
            "create",
            "add"
        ],
        "answer": 1,
        "explanation": "The `bind` method in JNDI is used to associate a new name with an object. It creates a new binding and throws an exception if the name is already bound."
    },
    {
        "question": "What is the difference between bind and rebind methods in JNDI?",
        "options": [
            "bind updates an existing object, while rebind creates a new one.",
            "bind creates a new binding, while rebind overwrites an existing binding.",
            "bind is used for databases, while rebind is used for directories.",
            "bind is faster than rebind."
        ],
        "answer": 1,
        "explanation": "The `bind` method creates a new binding and throws an exception if the name is already bound, while the `rebind` method overwrites an existing binding or creates a new one if it does not exist."
    },
    {
        "question": "True or False: JNDI can only be used to locate and access database connections.",
        "options": [
            "True",
            "False"
        ],
        "answer": 1,
        "explanation": "False. JNDI is a general-purpose API that can be used to locate and access a variety of resources, including EJBs, JMS destinations, configuration settings, and directory services, in addition to database connections."
    },
    {
        "question": "What is the function of a connection pool in JNDI?",
        "options": [
            "To manage database transaction states",
            "To reuse database connections for better performance",
            "To register database drivers dynamically",
            "To secure connections using encryption"
        ],
        "answer": 1,
        "explanation": "The primary function of a connection pool in JNDI is to reuse database connections for better performance. By pooling connections, the overhead of creating and closing connections for each request is avoided."
    },
    {
        "question": "Which JNDI method is used to modify an existing binding?",
        "options": [
            "bind",
            "rebind",
            "update",
            "list"
        ],
        "answer": 1,
        "explanation": "The `rebind` method in JNDI is used to modify an existing binding. It updates the object associated with the name or creates a new binding if it does not exist."
    },
    {
        "question": "Which XML file is commonly used to configure JNDI DataSources in Java EE applications?",
        "options": [
            "web.xml",
            "glassfish-resources.xml",
            "beans.xml",
            "faces-config.xml"
        ],
        "answer": 1,
        "explanation": "The `glassfish-resources.xml` file is commonly used to configure JNDI DataSources in Java EE applications when deploying on GlassFish servers. It specifies details like resource names, connection pools, and properties."
    },
    {
        "question": "What is the advantage of using a DataSource over DriverManager in JDBC?",
        "options": [
            "DataSource requires less memory.",
            "DataSource supports connection pooling.",
            "DataSource does not need JNDI binding.",
            "DataSource offers better thread safety."
        ],
        "answer": 1,
        "explanation": "The main advantage of using a `DataSource` over `DriverManager` in JDBC is that `DataSource` supports connection pooling. This improves application performance by reusing database connections instead of creating new ones for each request."
    },
    {
        "question": "What is a JNDI InitialContext?",
        "options": [
            "An interface for creating new bindings",
            "The starting point for interacting with a naming service",
            "A pool of database connections",
            "The primary configuration file for JNDI"
        ],
        "answer": 1,
        "explanation": "A JNDI `InitialContext` is the starting point for interacting with a naming service. It provides access to the naming service and methods to look up, bind, or unbind resources."
    },
    {
        "question": "Which method would you use to retrieve all bindings in a JNDI context?",
        "options": [
            "list",
            "lookup",
            "bind",
            "unbind"
        ],
        "answer": 0,
        "explanation": "The `list` method in JNDI is used to retrieve all bindings in a context. It provides a listing of names and associated objects within the context."
    },
    {
        "question": "True or False: The @Resource annotation can be used to inject any type of JNDI resource, such as a DataSource or JMS connection.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. The `@Resource` annotation can be used to inject various types of JNDI resources, such as a `DataSource`, JMS connection factory, or EJB references, simplifying resource access in enterprise applications."
    },
    {
        "question": "What is a common use case for JNDI in enterprise applications?",
        "options": [
            "Managing client-side scripts",
            "Storing persistent objects",
            "Configuring and locating resources like databases and queues",
            "Scheduling asynchronous tasks"
        ],
        "answer": 2,
        "explanation": "A common use case for JNDI in enterprise applications is configuring and locating resources such as databases, JMS queues, and EJBs. It provides a standard API for accessing these resources in a distributed environment."
    },
    {
        "question": "What is the primary purpose of Enterprise Java Beans (EJB)?",
        "options": [
            "To manage the presentation layer of web applications",
            "To encapsulate business logic in distributed applications",
            "To handle client-side scripting",
            "To create static web pages"
        ],
        "answer": 1,
        "explanation": "The primary purpose of Enterprise Java Beans (EJB) is to encapsulate business logic in distributed applications. EJBs handle tasks like transactions, security, and concurrency management, allowing developers to focus on business logic."
    },
    {
        "question": "What are the three types of Enterprise Beans?",
        "options": [
            "Session Beans, Message-Driven Beans, Entity Beans",
            "Stateful Beans, Stateless Beans, Singleton Beans",
            "Session Beans, Stateless Beans, Service Beans",
            "Session Beans, Message-Driven Beans, Cache Beans"
        ],
        "answer": 0,
        "explanation": "The three types of Enterprise Beans are Session Beans, Message-Driven Beans, and Entity Beans. Session Beans handle business logic, Message-Driven Beans process asynchronous messages, and Entity Beans represent persistent data (though they have been largely replaced by JPA)."
    },
    {
        "question": "What type of EJB is designed for managing asynchronous messages?",
        "options": [
            "Session Bean",
            "Message-Driven Bean",
            "Entity Bean",
            "Stateless Bean"
        ],
        "answer": 1,
        "explanation": "Message-Driven Beans are designed to manage asynchronous messages. They process messages from JMS queues or topics, enabling decoupled communication between components."
    },
    {
        "question": "Which type of session bean maintains a conversational state with the client?",
        "options": [
            "Stateless Bean",
            "Stateful Bean",
            "Singleton Bean",
            "Message-Driven Bean"
        ],
        "answer": 1,
        "explanation": "Stateful Beans maintain a conversational state with the client. This means they store client-specific data for the duration of the session, which is useful for workflows or shopping cart implementations."
    },
    {
        "question": "True or False: Stateless session beans can maintain a client’s conversational state.",
        "options": [
            "True",
            "False"
        ],
        "answer": 1,
        "explanation": "False. Stateless session beans do not maintain a client’s conversational state. Each method invocation is independent, making them ideal for lightweight, stateless operations."
    },
    {
        "question": "What is the main purpose of a Singleton session bean?",
        "options": [
            "To handle concurrent access by multiple clients",
            "To manage user sessions independently",
            "To listen for JMS messages",
            "To encapsulate database queries"
        ],
        "answer": 0,
        "explanation": "The main purpose of a Singleton session bean is to handle concurrent access by multiple clients. It is initialized once per application and provides shared access to global resources."
    },
    {
        "question": "Which of the following annotations defines a Stateless session bean?",
        "code_snippet": "@...\npublic class MyBean {\n    public String greet(String name) {\n        return \"Hello, \" + name;\n    }\n}",
        "options": [
            "@Stateful",
            "@Stateless",
            "@Singleton",
            "@MessageDriven"
        ],
        "answer": 1,
        "explanation": "The `@Stateless` annotation defines a Stateless session bean. These beans are used for operations that do not require maintaining a state across multiple method calls."
    },
    {
        "question": "What does the @PersistenceContext annotation do?",
        "options": [
            "Injects a dependency into an EJB",
            "Provides access to an EntityManager",
            "Defines the scope of an EJB",
            "Enables asynchronous processing"
        ],
        "answer": 1,
        "explanation": "The `@PersistenceContext` annotation provides access to an `EntityManager`, which is used for interacting with the persistence context to manage entities and perform database operations."
    },
    {
        "question": "What is the function of the @EJB annotation in a session bean?",
        "options": [
            "It defines the lifecycle of the bean",
            "It injects a reference to another EJB",
            "It configures transactional attributes",
            "It specifies the bean's persistence context"
        ],
        "answer": 1,
        "explanation": "The `@EJB` annotation injects a reference to another EJB. It simplifies dependency injection by allowing beans to access other beans without manual lookup."
    },
    {
        "question": "Which of the following annotations is used to define a Remote interface for an EJB?",
        "code_snippet": "@...\npublic interface MyRemoteBean {\n    String greet(String name);\n}",
        "options": [
            "@Local",
            "@Remote",
            "@EJB",
            "@SessionScoped"
        ],
        "answer": 1,
        "explanation": "The `@Remote` annotation defines a Remote interface for an EJB. This allows the bean to be accessed remotely, enabling distributed application architecture."
    },
    {
        "question": "Which type of EJB is shared across the entire application and exists for its lifetime?",
        "options": [
            "Stateless Bean",
            "Stateful Bean",
            "Singleton Bean",
            "Message-Driven Bean"
        ],
        "answer": 2,
        "explanation": "A Singleton Bean is shared across the entire application and exists for its lifetime. It is used for managing global application state or resources."
    },
    {
        "question": "What is the purpose of the @Asynchronous annotation in EJB?",
        "options": [
            "To handle asynchronous method invocations",
            "To make an EJB transactional",
            "To register an EJB for remote access",
            "To initialize a singleton bean"
        ],
        "answer": 0,
        "explanation": "The `@Asynchronous` annotation allows methods to be invoked asynchronously. It is commonly used to handle tasks that do not require an immediate response."
    },
    {
        "question": "Which of the following transactional attributes ensures a method is always executed within a new transaction?",
        "options": [
            "REQUIRED",
            "REQUIRES_NEW",
            "MANDATORY",
            "SUPPORTS"
        ],
        "answer": 1,
        "explanation": "The `REQUIRES_NEW` transactional attribute ensures that a method is always executed within a new transaction, regardless of whether a transaction is already active."
    },
    {
        "question": "Which EJB feature is used to handle concurrent access to Singleton beans?",
        "options": [
            "Thread pooling",
            "Container-managed concurrency",
            "State replication",
            "Lazy initialization"
        ],
        "answer": 1,
        "explanation": "Container-managed concurrency is used to handle concurrent access to Singleton beans. The EJB container manages locks and ensures thread safety for shared resources."
    },
    {
        "question": "What annotation is used to configure concurrency locks in Singleton beans?",
        "code_snippet": "@...(LockType.WRITE)\npublic void updateState() {\n    // Logic here\n}",
        "options": [
            "@Concurrency",
            "@Synchronized",
            "@Lock",
            "@ConcurrentAccess"
        ],
        "answer": 2,
        "explanation": "The `@Lock` annotation is used to configure concurrency locks in Singleton beans. It can specify `LockType.WRITE` or `LockType.READ` to control access to methods."
    },
    {
        "question": "True or False: A Stateful session bean is removed after the client finishes the session.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. A Stateful session bean maintains state for a specific client and is removed when the client finishes the session or explicitly ends it."
    },
    {
        "question": "Which method is invoked when a Stateful session bean is ready to be removed?",
        "options": [
            "destroy()",
            "@PreRemove",
            "@Remove",
            "@Shutdown"
        ],
        "answer": 2,
        "explanation": "The `@Remove` annotation marks a method that is invoked when a Stateful session bean is ready to be removed. This allows the bean to clean up resources before being destroyed."
    },
    {
        "question": "What is the purpose of the EntityManager in EJB?",
        "options": [
            "To manage transactions",
            "To provide CRUD operations on entities",
            "To handle asynchronous processing",
            "To enable distributed communication"
        ],
        "answer": 1,
        "explanation": "The `EntityManager` in EJB provides CRUD (Create, Read, Update, Delete) operations on entities. It acts as the primary interface for interacting with the persistence context, allowing developers to manage entities and their lifecycle."
    },
    {
        "question": "What is the difference between a Local and a Remote interface in EJB?",
        "options": [
            "A Local interface can be accessed remotely, while a Remote interface cannot.",
            "A Local interface is for intra-application communication, while a Remote interface is for inter-application communication.",
            "A Remote interface provides better performance than a Local interface.",
            "A Remote interface is used only for stateless beans."
        ],
        "answer": 1,
        "explanation": "A Local interface in EJB is used for intra-application communication, while a Remote interface is used for inter-application communication. Local interfaces are optimized for performance, as they avoid the overhead of remote communication."
    },
    {
        "question": "Which lifecycle callback is used to perform initialization in a Stateful session bean?",
        "options": [
            "@Init",
            "@PostConstruct",
            "@Startup",
            "@Begin"
        ],
        "answer": 1,
        "explanation": "The `@PostConstruct` annotation is used to perform initialization in a Stateful session bean. It marks a method that should be invoked after dependency injection is complete."
    },
    {
        "question": "What is the main purpose of JMS in Java applications?",
        "options": [
            "To manage database connections",
            "To facilitate messaging between software components",
            "To handle HTTP requests and responses",
            "To implement RESTful web services"
        ],
        "answer": 1,
        "explanation": "The main purpose of Java Message Service (JMS) is to facilitate messaging between software components. It provides a standard way to create, send, receive, and read messages in a distributed environment."
    },
    {
        "question": "Which of the following is NOT a characteristic of JMS?",
        "options": [
            "Asynchronous",
            "Reliable",
            "Loosely coupled",
            "Tightly coupled"
        ],
        "answer": 3,
        "explanation": "JMS is not tightly coupled. It is designed to be loosely coupled, asynchronous, and reliable, allowing components to communicate without direct dependencies."
    },
    {
        "question": "What are the two main messaging models supported by JMS?",
        "options": [
            "Point-to-Point and Publish-Subscribe",
            "Request-Response and Event-Driven",
            "Synchronous and Asynchronous",
            "Stream-Based and Text-Based"
        ],
        "answer": 0,
        "explanation": "The two main messaging models supported by JMS are Point-to-Point (PTP) and Publish-Subscribe (Pub-Sub). PTP involves a single producer and a single consumer, while Pub-Sub allows multiple consumers to receive messages from a single producer."
    },
    {
        "question": "In the Point-to-Point (PTP) messaging model, what is the main characteristic?",
        "options": [
            "Messages are broadcast to all consumers",
            "Messages are retained until consumed or expired",
            "A message has multiple consumers",
            "Messages are delivered in real-time only"
        ],
        "answer": 1,
        "explanation": "In the Point-to-Point (PTP) messaging model, messages are retained until they are consumed or expired. Each message is delivered to a single consumer, ensuring reliable communication."
    },
    {
        "question": "What does the 'durable subscription' feature in the Publish-Subscribe model provide?",
        "options": [
            "Persistent delivery of messages to subscribers who were offline",
            "Immediate deletion of messages after they are read",
            "Reduction in system overhead",
            "Enhanced encryption for subscriber messages"
        ],
        "answer": 0,
        "explanation": "The 'durable subscription' feature in the Publish-Subscribe model ensures that messages are persistently delivered to subscribers who were offline at the time of publication. This guarantees message delivery once the subscriber reconnects."
    },
    {
        "question": "What is the role of the 'connection factory' in JMS?",
        "options": [
            "To produce messages",
            "To create connections to the provider",
            "To handle message encryption",
            "To store queues and topics"
        ],
        "answer": 1,
        "explanation": "The connection factory in JMS is responsible for creating connections to the provider. It serves as an entry point for clients to interact with the messaging system."
    },
    {
        "question": "What annotation is used to inject a connection factory in JMS?",
        "code_snippet": "@...(lookup = \"MyConnectionFactory\")\nprivate ConnectionFactory connectionFactory;",
        "options": [
            "@Inject",
            "@Resource",
            "@JMSConnection",
            "@Factory"
        ],
        "answer": 1,
        "explanation": "The `@Resource` annotation is used to inject a connection factory in JMS. It allows the developer to specify the JNDI lookup name of the connection factory for resource injection."
    },
    {
        "question": "What method is used to receive messages synchronously in JMS?",
        "options": [
            "listen",
            "fetch",
            "receive",
            "onMessage"
        ],
        "answer": 2,
        "explanation": "The `receive` method is used to receive messages synchronously in JMS. It blocks until a message is available or the timeout expires."
    },
    {
        "question": "How does an asynchronous message consumer process messages in JMS?",
        "options": [
            "By calling the receive method in a loop",
            "By registering a MessageListener",
            "By using a CompletionListener",
            "By polling the message queue"
        ],
        "answer": 1,
        "explanation": "An asynchronous message consumer in JMS processes messages by registering a `MessageListener`. The listener's `onMessage` method is automatically called when a message arrives."
    },
    {
        "question": "Which part of a JMS message contains routing and delivery information?",
        "options": [
            "Header",
            "Body",
            "Properties",
            "Metadata"
        ],
        "answer": 0,
        "explanation": "The `Header` of a JMS message contains routing and delivery information, such as the message ID, timestamp, and destination."
    },
    {
        "question": "What is the purpose of message selectors in JMS?",
        "options": [
            "To prioritize messages",
            "To filter messages based on SQL-like expressions",
            "To encrypt sensitive message content",
            "To handle message acknowledgment"
        ],
        "answer": 1,
        "explanation": "Message selectors in JMS are used to filter messages based on SQL-like expressions. This allows consumers to retrieve only the messages that match specific criteria."
    },
    {
        "question": "Which of the following methods is used for transactional message sending in JMS?",
        "options": [
            "commit",
            "rollback",
            "acknowledge",
            "All of the above"
        ],
        "answer": 3,
        "explanation": "In JMS transactions, `commit` is used to finalize changes, `rollback` to undo changes, and `acknowledge` to confirm message delivery. All these methods are essential for transactional messaging."
    },
    {
        "question": "True or False: Temporary destinations in JMS last only for the duration of the connection in which they were created.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. Temporary destinations in JMS, such as temporary queues or topics, last only for the duration of the connection in which they were created. Once the connection is closed, the temporary destinations are deleted."
    },
    {
        "question": "What does the following code snippet achieve in JMS?",
        "code_snippet": "try(JMSContext context = connectionFactory.createContext()) {\n    JMSProducer producer = context.createProducer();\n    TextMessage message = context.createTextMessage(\"Hello World!\");\n    producer.send(queue, message);\n}",
        "options": [
            "Creates and sends a TextMessage to a topic",
            "Creates and sends a TextMessage to a queue",
            "Receives a message from a queue",
            "Registers a message listener"
        ],
        "answer": 1,
        "explanation": "The code snippet creates and sends a `TextMessage` to a queue. The `JMSProducer` is used to send messages, and the queue specifies the destination."
    },
    {
        "question": "Which JMS feature ensures that a message is delivered to only one consumer?",
        "options": [
            "Durable subscription",
            "Point-to-Point model",
            "Publish-Subscribe model",
            "Message persistence"
        ],
        "answer": 1,
        "explanation": "The Point-to-Point (PTP) model in JMS ensures that a message is delivered to only one consumer. Each message is consumed by a single receiver, guaranteeing exclusive delivery."
    },
    {
        "question": "What is the purpose of the JMSContext object?",
        "options": [
            "To manage connections to the provider",
            "To encapsulate both connection and session",
            "To configure message priority levels",
            "To filter messages"
        ],
        "answer": 1,
        "explanation": "The `JMSContext` object encapsulates both the connection and session in JMS, simplifying the API for messaging operations. It provides a single interface for producing, consuming, and managing messages."
    },
    {
        "question": "Which feature of JMS allows delayed delivery of messages?",
        "options": [
            "Time-to-live",
            "Delivery delay",
            "Message persistence",
            "Transaction scope"
        ],
        "answer": 1,
        "explanation": "The `delivery delay` feature in JMS allows delayed delivery of messages. It specifies a time interval after which the message will be delivered to the consumer."
    },
    {
        "question": "What is the primary purpose of a QueueBrowser in JMS?",
        "options": [
            "To retrieve messages from a queue",
            "To browse the header values of messages in a queue",
            "To manage the lifecycle of messages in a queue",
            "To delete expired messages from a queue"
        ],
        "answer": 1,
        "explanation": "The primary purpose of a `QueueBrowser` in JMS is to browse the header values of messages in a queue without removing them. It allows for inspection of messages to determine their contents or metadata."
    },
    {
        "question": "Which JMS delivery mode ensures that messages survive application restarts?",
        "options": [
            "Non-persistent",
            "Persistent",
            "Temporary",
            "Durable"
        ],
        "answer": 1,
        "explanation": "The `Persistent` delivery mode ensures that messages survive application restarts by saving them to durable storage until they are successfully delivered."
    },
    {
        "question": "What is a Message-Driven Bean (MDB) in JMS?",
        "options": [
            "A synchronous message consumer",
            "An asynchronous message consumer",
            "A factory for creating message producers",
            "A specialized type of topic in JMS"
        ],
        "answer": 1,
        "explanation": "A `Message-Driven Bean` (MDB) in JMS is an asynchronous message consumer that processes messages from a queue or topic. MDBs are used to decouple message processing from the client that sends the message."
    },
    {
        "question": "What is the main purpose of MicroProfile Security in microservices?",
        "options": [
            "To enable centralized database configurations",
            "To manage memory allocations",
            "To provide authentication and authorization using JWT",
            "To monitor service availability"
        ],
        "answer": 2,
        "explanation": "The main purpose of MicroProfile Security is to provide authentication and authorization using JWT (JSON Web Tokens). It simplifies securing microservices by integrating identity and access management."
    },
    {
        "question": "What are the key security concepts for protecting microservices?",
        "options": [
            "Identity, Encryption, Authorization",
            "Authentication, Authorization, Sessions",
            "Authentication, Monitoring, Logging",
            "Authorization, Encryption, Caching"
        ],
        "answer": 1,
        "explanation": "The key security concepts for protecting microservices are authentication, authorization, and session management. Authentication verifies user identity, authorization enforces access control, and sessions track user interactions."
    },
    {
        "question": "Why are tokens used in microservices security?",
        "options": [
            "To reduce authentication time",
            "To store the user’s password securely",
            "To store and propagate the security context",
            "To enable asynchronous service calls"
        ],
        "answer": 2,
        "explanation": "Tokens are used in microservices security to store and propagate the security context. They encapsulate user identity and access permissions, enabling secure communication across services."
    },
    {
        "question": "What is the role of an identity provider in a microservice architecture?",
        "options": [
            "To act as the database of user credentials",
            "To manage the authentication process and issue tokens",
            "To perform distributed logging across services",
            "To monitor service health for security breaches"
        ],
        "answer": 1,
        "explanation": "The role of an identity provider in a microservice architecture is to manage the authentication process and issue tokens. It serves as a central authority for verifying user identity and granting access to services."
    },
    {
        "question": "Which of the following is NOT a claim in a JWT?",
        "options": [
            "exp",
            "iss",
            "sub",
            "hash"
        ],
        "answer": 3,
        "explanation": "The `hash` claim is not a standard claim in JWT. Standard claims include `exp` (expiration), `iss` (issuer), and `sub` (subject), among others."
    },
    {
        "question": "What are the three main components of a JWT?",
        "options": [
            "Header, Payload, Body",
            "Metadata, Payload, Signature",
            "Header, Payload, Signature",
            "Header, Body, Algorithm"
        ],
        "answer": 2,
        "explanation": "A JWT consists of three main components: the Header, which specifies the token type and signing algorithm; the Payload, which contains claims; and the Signature, which ensures the token's integrity."
    },
    {
        "question": "True or False: JWT tokens are signed to ensure integrity but may not always be encrypted.",
        "options": [
            "True",
            "False"
        ],
        "answer": 0,
        "explanation": "True. JWT tokens are signed to ensure integrity, allowing the recipient to verify that the token was not tampered with. However, they are not always encrypted, so the payload can be readable if not encrypted."
    },
    {
        "question": "What is contained in the payload section of a JWT?",
        "options": [
            "The token's expiration time",
            "Information about the signing algorithm",
            "Claims and custom data about the user",
            "The token's key identifier (kid)"
        ],
        "answer": 2,
        "explanation": "The payload section of a JWT contains claims and custom data about the user. This section is base64-encoded and includes both standard and custom claims."
    },
    {
        "question": "Which field in the JWT header defines the signing algorithm used?",
        "options": [
            "typ",
            "alg",
            "iss",
            "aud"
        ],
        "answer": 1,
        "explanation": "The `alg` field in the JWT header specifies the algorithm used to sign the token, such as `HS256` or `RS256`."
    },
    {
        "question": "What is the purpose of the groups claim in a JWT?",
        "options": [
            "To specify the intended audience of the token",
            "To define the user's roles for RBAC",
            "To store the token's expiration details",
            "To provide the token's unique identifier"
        ],
        "answer": 1,
        "explanation": "The `groups` claim in a JWT defines the user's roles for Role-Based Access Control (RBAC). It is commonly used in MicroProfile Security for access management."
    },
    {
        "question": "Which of these algorithms is NOT recommended for signing a JWT in MicroProfile Security?",
        "options": [
            "HS256",
            "RS256",
            "ES256",
            "PS256"
        ],
        "answer": 0,
        "explanation": "The `HS256` algorithm is not recommended for signing JWTs in MicroProfile Security because it uses a shared secret, which is less secure than asymmetric algorithms like `RS256` and `ES256`."
    },
    {
        "question": "What is the primary benefit of using MicroProfile JWT in a microservices architecture?",
        "options": [
            "It enforces token encryption for secure communication",
            "It standardizes role-based access control (RBAC)",
            "It reduces communication overhead between services",
            "It automatically creates tokens for users"
        ],
        "answer": 1,
        "explanation": "The primary benefit of using MicroProfile JWT is its standardization of Role-Based Access Control (RBAC), which simplifies authentication and authorization across microservices."
    },
    {
        "question": "True or False: Services using MicroProfile JWT must store user session data on the server.",
        "options": [
            "True",
            "False"
        ],
        "answer": 1,
        "explanation": "False. Services using MicroProfile JWT do not store session data on the server. The token itself contains all the necessary information, allowing stateless authentication."
    },
    {
        "question": "What is a key feature of JWT tokens in MicroProfile Security?",
        "options": [
            "They allow services to introspect tokens remotely or locally",
            "They enforce encryption for data integrity",
            "They ensure tokens are always kept confidential",
            "They store authentication keys for secure access"
        ],
        "answer": 0,
        "explanation": "JWT tokens in MicroProfile Security allow services to introspect tokens remotely or locally to extract claims and validate the token's authenticity."
    },
    {
        "question": "What is required to verify a JWT issued by a trusted provider?",
        "options": [
            "The token's private key",
            "The token's claims and public key",
            "The token's algorithm and payload",
            "Only the token's signature"
        ],
        "answer": 1,
        "explanation": "To verify a JWT issued by a trusted provider, the token's claims and public key are required. The public key is used to verify the signature, ensuring the token's integrity."
    },
    {
        "question": "What does the following annotation achieve in a controller?",
        "code_snippet": "@Inject\n@Claim(\"custom-value\")\nprivate ClaimValue<String> custom;",
        "options": [
            "Configures the JWT claim for the user ID",
            "Injects a custom claim value from the JWT",
            "Overrides the default token signature",
            "Verifies the token signature in the controller"
        ],
        "answer": 1,
        "explanation": "The annotation injects a custom claim value from the JWT into the controller. This allows the application to access specific claims directly in the code."
    },
    {
        "question": "What does the @LoginConfig annotation specify?",
        "options": [
            "The login credentials for accessing the service",
            "The authentication mechanism for the application",
            "The claims required for user sessions",
            "The default audience for JWT tokens"
        ],
        "answer": 1,
        "explanation": "The `@LoginConfig` annotation specifies the authentication mechanism for the application, such as BASIC or FORM-based authentication."
    },
    {
        "question": "What should be written in the blank space, such that the input text will set the 'title' property of a managed bean exposed with the name 'book'?",
        "code_snippet": "//In a xhtml file\n<h:inputText value='______'/>",
        "options": [
            "#{book.title}",
            "#{book_title}",
            "#{book/title}",
            "#{book.title[0]}"
        ],
        "answer": 0,
        "explanation": "To bind the input text to the `title` property of a managed bean named `book`, the correct syntax is `#{book.title}`. This is the correct EL (Expression Language) syntax for accessing properties in JSF."
    },
    {
        "question": "Which statements, regarding JSF converters, are correct?",
        "options": [
            "They can be registered in faces-config.xml to become active.",
            "They must be annotated with @Component to work.",
            "They must implement the Converter interface.",
            "They need to extend a specific Converter base class."
        ],
        "answer": 2,
        "explanation": "JSF converters must implement the `Converter` interface to handle object-to-string and string-to-object conversions. While registration in `faces-config.xml` or using annotations like `@FacesConverter` is valid, it is not required to extend any base class."
    },
    {
        "question": "The design pattern used in the JSF component rendering model is:",
        "options": [
            "Observer",
            "MVC (Model-View-Controller)",
            "Strategy",
            "Factory"
        ],
        "answer": 2,
        "explanation": "JSF uses the `Strategy` design pattern for its rendering model, allowing different renderers to handle specific component types without affecting the core logic."
    },
    {
        "question": "Which statements, regarding the front controller design pattern, are correct?",
        "options": [
            "In Java EE, a front controller is typically implemented as a servlet.",
            "It provides a centralized entry point for handling requests.",
            "It enables dynamic request routing using annotations.",
            "It distributes request handling logic to multiple controllers."
        ],
        "answer": 1,
        "explanation": "The front controller design pattern provides a centralized entry point for handling requests. In Java EE, it is commonly implemented using a servlet or a filter, such as the `FacesServlet` in JSF."
    },
    {
        "question": "What tag should be written in the blank space, in order to have a valid JSF navigation rule?",
        "code_snippet": "<navigation-rule>\n<from-view-id>/firstPage.xhtml</from-view-id>\n<navigation-case>\n<...>success</...>\n<to-view-id>/secondPage.xhtml</to-view-id>\n</navigation-case>\n</navigation-rule>",
        "options": [
            "outcome",
            "case",
            "command",
            "from-outcome"
        ],
        "answer": 3,
        "explanation": "The `from-outcome` tag specifies the outcome value in a JSF navigation case. It determines the navigation flow based on the action result or outcome string."
    },
    {
        "question": "The functionality of an inputText JSF component is implemented in a class of the following types:",
        "options": [
            "UIInput",
            "UIOutput",
            "ComponentBase",
            "ValueHolder"
        ],
        "answer": 0,
        "explanation": "UIInput is the base class for all JSF components that accept user input. It implements the core functionality for input processing."
    },
    {
        "question": "The functionality of an inputText JSF component is implemented in a class of the following types:",
        "options": [
            "EditableValueHolder",
            "UIBase",
            "RenderedValueHolder",
            "InputBase"
        ],
        "answer": 0,
        "explanation": "EditableValueHolder is an interface that defines methods for editable components, which are responsible for holding and processing values in JSF."
    },
    {
        "question": "What is the short name of the class that should be written in the blank space, in order to have a syntactically valid JSF validator method?",
        "code_snippet": "public void validateName(FacesContext context, UIComponent component, Object value) {\n    String dogName = (String) value;\n    if (dogName.isEmpty()) {\n        ((UIInput) component).setValid(false);\n        context.addMessage(component.getClientId(context), new __________(\"Bad dog!\"));\n    }\n}",
        "options": [
            "FacesMessage",
            "UIMessage",
            "ValidationMessage",
            "ErrorMessage"
        ],
        "answer": 0,
        "explanation": "FacesMessage is the correct class to use when adding validation messages in JSF. It encapsulates the message details, including its severity level and content, making it appropriate for this context."
    },
    {
        "question": "Which of the following represents a standard CDI or JSF annotation that could be used to specify a JSF managed bean scope?",
        "options": [
            "@ResponseScoped",
            "@SessionScoped",
            "@AjaxScoped",
            "@BeanScoped"
        ],
        "answer": 1,
        "explanation": "@SessionScoped is a standard JSF annotation that specifies the bean's scope lasts for the duration of a user's session."
    },
    {
        "question": "What is the short name of the annotation that should be written in the blank space, such that the instance of the bean below is accessible in the JSF pages with the name 'studentBean'?",
        "code_snippet": "@ViewScoped\n_________\npublic class StudentBean { }",
        "options": [
            "@FacesBean",
            "@Controller",
            "@ManagedBean",
            "@Publish"
        ],
        "answer": 2,
        "explanation": "@ManagedBean is the correct annotation in JSF for making a bean accessible in the JSF pages. When applied, the bean is automatically available under the name 'studentBean' in the EL (Expression Language) context."
    },
    {
        "question": "What should be written in the blank space in order to define an EJB that processes messages asynchronously?",
        "code_snippet": "@ ....(mappedName=\"destination\")\npublic class MyEnterpriseBean implements MessageListener{\n.......\n}",
        "options": [
            "JMSContext",
            "Stateless",
            "MessageDriven",
            "EventDriven"
        ],
        "answer": 2,
        "explanation": "The `@MessageDriven` annotation is used to define a message-driven bean (MDB) in EJB. MDBs are designed to process messages asynchronously from a messaging system, such as JMS."
    },
    {
        "question": "Which of the following statements regarding JMS selector are correct:",
        "options": [
            "Allows a message producer to specify the nature of its messages.",
            "Can be specified when you create a consumer.",
            "Can be specified when you create a producer.",
            "May use the message body content in order to specify the filter."
        ],
        "answer": 1,
        "explanation": "A JMS selector can be specified when creating a consumer. It uses a SQL-like syntax to filter messages based on message properties, ensuring only relevant messages are received by the consumer."
    },
    {
        "question": "Which of the following types describe Destination administrative objects:",
        "options": [
            "Topic",
            "MessagePool",
            "Channel",
            "Selector"
        ],
        "answer": 0,
        "explanation": "A `Topic` is one of the two types of Destination objects in JMS. Topics are used for publish-subscribe messaging, allowing multiple consumers to receive messages from the same source."
    },
    {
        "question": "What should be written in the blank space in order to produce a message:",
        "code_snippet": "JMSProducer producer = context.createProducer();\nproducer. ______(destination, message);",
        "options": [
            "send",
            "stream",
            "enqueue",
            "out"
        ],
        "answer": 0,
        "explanation": "The `send` method is used in JMS to produce a message and send it to the specified destination. It is the standard method for message delivery in JMS."
    },
    {
        "question": "What should be written in the blank space in order to consume message in a synchronus manner:",
        "code_snippet": "JMSConsumer consumer = context.createConsumer(destination);\nMessage message = consumer. _____();",
        "options": [
            "receive",
            "stream",
            "consume",
            "dequeue"
        ],
        "answer": 0,
        "explanation": "The `receive` method is used to consume messages in a synchronous manner in JMS. It blocks the consumer until a message is available or the timeout expires."
    },
    {
        "question": "What could be written in the blank space in order to complete a transactional JMS session:",
        "code_snippet": "JMSContext context = connectionFactory.createContext(JMSContext.SESSION_TRANSACTED);\ncontext. ____();",
        "options": [
            "acknowledge",
            "commit",
            "complete",
            "endTransaction"
        ],
        "answer": 1,
        "explanation": "The `commit` method is used to complete a transactional JMS session. It commits all the messages sent or received during the session as part of a transaction."
    },
    {
        "question": "Which of the following statements regarding JMS (Java Message Service) are correct:",
        "options": [
            "Represents the default messaging implementation on the Java platform",
            "Is specific to AMQP protocol",
            "Defines a common set of Java interfaces regarding messaging.",
            "Is based on the reactive programming paradigm."
        ],
        "answer": 2,
        "explanation": "JMS defines a common set of Java interfaces and classes for messaging, providing a standard way to handle message-oriented middleware in Java applications."
    },
    {
        "question": "A local transaction that determines the success or failure of a saga is called:",
        "options": [
            "Trigger",
            "Pivot",
            "Coordinator",
            "Critical"
        ],
        "answer": 1,
        "explanation": "In the Saga pattern, the `Pivot` is the local transaction that determines the overall success or failure of the saga. If the pivot transaction fails, compensating transactions are executed."
    },
    {
        "question": "Eventual consistency is a form of:",
        "options": [
            "Weak consistency",
            "Casual consistency",
            "Strong consistency",
            "Monotonic consistency"
        ],
        "answer": 0,
        "explanation": "Eventual consistency is a form of weak consistency in distributed systems, where updates to a system will propagate eventually, but not immediately, ensuring that all nodes eventually converge to the same state."
    },
    {
        "question": "In order to ensure that every node instance is always allowing read or writes, regardless of the state of the network, we must sacrifice:",
        "options": [
            "Consistency",
            "Performance",
            "Availability",
            "Isolation"
        ],
        "answer": 0,
        "explanation": "According to the CAP theorem, to ensure high availability in distributed systems, consistency must be sacrificed when there is a network partition."
    },
    {
        "question": "Which of the following phases are part of the Two Phase Commit(2PC) pattern:",
        "options": [
            "Lock",
            "Validate",
            "Commit",
            "Synchronize"
        ],
        "answer": 2,
        "explanation": "The `Commit` phase is a critical part of the Two-Phase Commit (2PC) protocol, where the transaction coordinator instructs all participants to finalize the transaction after ensuring all participants are prepared."
    },
    {
        "question": "Which of the following characteristics are specific to a microservice-based application?",
        "options": [
            "Components usually share the same databases",
            "Ensuring database transactions isolation may be difficult",
            "Ensuring database transactions consistency may be difficult",
            "It can be easily deployed."
        ],
        "answer": 2,
        "explanation": "In microservice-based applications, ensuring database transactions consistency can be difficult because each microservice often manages its own database, leading to challenges in maintaining a consistent state across multiple services."
    },
    {
        "question": "A microservice should be:",
        "options": [
            "Implemented as a singleton",
            "Exposing a standard interface",
            "Integrated with the other microservices",
            "Sharing data with sister microservices"
        ],
        "answer": 1,
        "explanation": "A microservice should expose a standard interface, typically via REST or other protocols, to allow other microservices or clients to interact with it in a loosely coupled manner."
    },
    {
        "question": "Which type of a service client implementation is preferred in situations when service availability is low or overloaded with demand?",
        "options": [
            "Asynchronous",
            "Synchronous"
        ],
        "answer": 0,
        "explanation": "An asynchronous client implementation allows requests to be made without blocking the execution flow, making it ideal for handling situations with low service availability or high demand."
    },
    {
        "question": "What should be written in the blank space, in order to obtain a reference to an object that counts invocations to service methods?",
        "code_snippet": "public class Controller {\n @Inject\n _______(name = \"counter\")\nprivate Counter counter;\n}",
        "options": [
            "@Metric",
            "@Histogram",
            "@TelemetryData",
            "@Counter"
        ],
        "answer": 0,
        "explanation": "The `@Metric` annotation is used to inject a metric object, such as a counter, that tracks statistics or invocations of service methods in microservices."
    },
    {
        "question": "In order to deal with unexpected failures, a microservice API should offer support for:",
        "options": [
            "Report diagnostics (telemetry data)",
            "Web sessions passivation and reactivation",
            "Replicate the information in a database shared by all services",
            "Report users that overload the systems"
        ],
        "answer": 0,
        "explanation": "Reporting diagnostics and telemetry data allows microservices to monitor their health and recover from unexpected failures by providing essential operational insights."
    },
    {
        "question": "The representation of a UISelectOne component could be described by the following JSF classes:",
        "options": [
            "HtmlSelectOneListbox",
            "SelectOneRadio",
            "SelectOneListbox",
            "SelectOneMenu"
        ],
        "answer": 0,
        "explanation": "The `HtmlSelectOneListbox` class represents the UISelectOne component in JSF, which is used for rendering a list box for single selection."
    },
    {
        "question": "Regarding Web applications, the default Java EE approach is:",
        "options": [
            "client-centric",
            "server-centric"
        ],
        "answer": 1,
        "explanation": "Java EE applications are server-centric, meaning most of the processing logic happens on the server side, with the client handling minimal processing."
    },
    {
        "question": "In the context of Java programming, EJB stands for:",
        "options": [
            "Electrical Junction Box",
            "Emergency Java Backup",
            "Easy JoB",
            "Enterprise Java Beans"
        ],
        "answer": 3,
        "explanation": "EJB stands for Enterprise Java Beans, which is a specification for building distributed, transactional, and portable applications in Java."
    },
    {
        "question": "Which MIME type should be used by a servlet, in order to inform the client that it returns an HTML page?",
        "options": [
            "application/html",
            "text/html",
            "html/text",
            "servlet/html"
        ],
        "answer": 1,
        "explanation": "The `text/html` MIME type is used to indicate that the servlet returns an HTML page. It is a standard MIME type for web content."
    },
    {
        "question": "An application that must be available 24/7 has the property of:",
        "options": [
            "Mission critical",
            "Scalable",
            "High availability",
            "Clustered"
        ],
        "answer": 2,
        "explanation": "High availability refers to systems that are operational and accessible 24/7, ensuring minimal downtime even during failures."
    },
    {
        "question": "In the context of enterprise programming, which features ensure the portability of an application:",
        "options": [
            "Deployment of the same codebase on application servers from different suppliers",
            "The ability to use various database management systems, without altering the codebase",
            "The ability to compile the codebase for any operating system",
            "Running on various processor architectures and operating systems"
        ],
        "answer": 0,
        "explanation": "Portability in enterprise programming is achieved when the same codebase can be deployed across different application servers without modifications, ensuring compatibility with Java EE specifications."
    },
    {
        "question": "Considering the servlet annotation below, what should be written in the blank space so that the invocation\nhttp://localhost:8080/App/beatae\nsends a request to the servlet?",
        "code_snippet": "@WebServlet( ______ = {\"/beatae\"})",
        "options": [
            "dispatchRoute",
            "query",
            "mapped",
            "value"
        ],
        "answer": 3,
        "explanation": "The `value` attribute in the `@WebServlet` annotation specifies the URL pattern that the servlet will handle. In this case, `/beatae` maps requests to the servlet."
    },
    {
        "question": "JSP (Java Server Pages) components are part of the following tier:",
        "options": [
            "Bussiness",
            "Client",
            "Web",
            "Model"
        ],
        "answer": 2,
        "explanation": "JSP components belong to the Web tier of a Java EE application, responsible for generating dynamic web content and handling presentation logic."
    },
    {
        "question": "What should be written in the blank space in order to create an attribute named \"version\", shared at session level?",
        "code_snippet": "public void doGet(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nsession. _____(\"version\", \"1.0\");\n // the rest of the doGet method",
        "options": [
            "publish",
            "share",
            "setAttribute",
            "setParameter"
        ],
        "answer": 2,
        "explanation": "The `setAttribute` method is used to store an attribute in the session scope, making it accessible across the user's session."
    },
    {
        "question": "In a Java EE project, the application descriptor web.xml is located in the following directory:",
        "options": [
            "properties",
            "WEB-INF",
            "META-INF",
            "root"
        ],
        "answer": 1,
        "explanation": "The `web.xml` file is the deployment descriptor for Java EE web applications and is located in the `WEB-INF` directory."
    },
    {
        "question": "What should be written in the blank space, in order to use the custom tag aut from the library as <nihil:aut>?",
        "code_snippet": "<%@ taglib uri=\"/WEB-INF/tlds/mylibrary\" ________=\"nihil\" %>",
        "options": [
            "include",
            "prefix",
            "suffix",
            "namespace"
        ],
        "answer": 1,
        "explanation": "The `prefix` attribute in the `taglib` directive specifies the custom tag namespace prefix to be used in JSP files, such as `nihil` in this case."
    },
    {
        "question": "Which statements, regarding JSTL (Java Standard Tag Libraries) technology, are correct?",
        "options": [
            "In order to use a standard tag, its class handler must be mapped using a tag library descriptor (TLD)",
            "Java EE application server include by default implementations of these tags",
            "JSTL can be used in JSP pages, but not in JSP fragments (.tag files)"
        ],
        "answer": 1,
        "explanation": "Java EE application servers typically include implementations of JSTL tags by default, making them readily available for use in web applications."
    },
    {
        "question": "Which statements, regarding JSTL (Java Standard Tag Libraries) technology, are correct?",
        "options": [
            "In order to use a standard tag, its class handler must be mapped using a tag library descriptor (TLD)",
            "A JSTL library contains JSP custom tags",
            "JSTL can be used in JSP pages, but not in JSP fragments (.tag files)"
        ],
        "answer": 1,
        "explanation": "JSTL libraries consist of custom tags that provide standard solutions for common tasks in JSP development, such as iteration and conditionals."
    },
    {
        "question": "What reference to a predefined JSP object should be written in the blank space, in order to include the message in the response sent to the client?",
        "code_snippet": "<%\nString message = \"voluptatibus\";\n__________.println(message);\n%>",
        "options": [
            "out",
            "system",
            "console",
            "command"
        ],
        "answer": 0,
        "explanation": "The `out` object in JSP is used to write content to the HTTP response. In this case, it prints the message `voluptatibus` to the client's browser."
    },
    {
        "question": "What type of listener should be created in order to be informed about a session being passivated?",
        "options": [
            "HttpSessionActivationListener",
            "ServletContextListener",
            "AsyncListener",
            "HttpSessionPassivationListener"
        ],
        "answer": 0,
        "explanation": "The `HttpSessionActivationListener` interface allows objects to be notified when a session is passivated or activated, typically in distributed environments."
    },
    {
        "question": "Which statements, regarding JSP (Java Server Pages), are correct?",
        "options": [
            "In order to access the application scope, we can use the predefined object servletContext",
            "In a JSP page we can only use Java classes from java.lang and java.util",
            "A JSP expression can be written either in Java or using expression language (EL)",
            "JSP comments are included in the output sent to the client"
        ],
        "answer": 2,
        "explanation": "JSP expressions can be written in Java or using Expression Language (EL), which simplifies the syntax and allows for cleaner integration with backend objects."
    },
    {
        "question": "Considering the filter annotation below, what should be written in the blank space so that the invocation http://localhost:8080/App/quo is intercepted by the filter?",
        "code_snippet": "@WebFilter(__________= {\"/quo\"})",
        "options": [
            "regex",
            "urlPatterns",
            "appliesTo",
            "suffix"
        ],
        "answer": 1,
        "explanation": "The `urlPatterns` attribute in the `@WebFilter` annotation specifies the URL patterns that the filter should intercept, such as `/quo` in this case."
    },
    {
        "question": "Consider `em` as EntityManager object. What should be written in the blank space in order to obtain an entity corresponding to a primary key (generating an SQL SELECT)?",
        "code_snippet": "int pk = 1;\nStudent student = em. _____(Student.class, pk);",
        "options": [
            "findById",
            "find",
            "read",
            "lookup"
        ],
        "answer": 1,
        "explanation": "The `find` method of the `EntityManager` is used to retrieve an entity by its primary key. It generates a SQL `SELECT` query under the hood."
    },
    {
        "question": "A city belongs to a country. What is the short name of the JPA annotation that could be used in the Country class to map the association between the two?",
        "code_snippet": "//In the Country class\n ______(mappedBy = \"country\" )\nprivate List<City> cities;",
        "options": [
            "@ManyToOne",
            "@ManyToMany",
            "@OneToOne",
            "@OneToMany"
        ],
        "answer": 3,
        "explanation": "The `@OneToMany` annotation is used to map a one-to-many relationship in JPA. In this case, a country has a list of cities, and the association is defined in the `City` entity."
    },
    {
        "question": "In order to update a JPA entity (generating an SQL UPDATE), an EntityManager offers the following methods:",
        "options": [
            "update",
            "saveOrUpdate",
            "None of them",
            "persistOrUpdate"
        ],
        "answer": 2,
        "explanation": "JPA does not provide a direct `update` method. Updates are performed automatically when an entity is modified and the transaction is committed, as long as the entity is managed."
    },
    {
        "question": "What is the short name of the JPA annotation that should be written in the blank space, in order to define a JPA listener that is invoked after an entity is deleted in the database?",
        "code_snippet": "public class EntityLogger {\n_______\npublic void log(Object entity) {\n // Do something\n}\n}",
        "options": [
            "@AfterRemove",
            "@PostDelete",
            "@AfterEvict",
            "@PostRemove"
        ],
        "answer": 3,
        "explanation": "The `@PostRemove` annotation is used to define a JPA callback method that is invoked after an entity is removed from the database."
    },
    {
        "question": "What JPA inheritance strategy addresses the situation in which there is one entity class for all the tables forming the hierarchy?",
        "options": [
            "Joined",
            "Single Table",
            "Mapped Superclass",
            "Table Per Class"
        ],
        "answer": 1,
        "explanation": "The `Single Table` strategy uses a single database table to store data for all the entity classes in the inheritance hierarchy, simplifying queries and ensuring better performance."
    },
    {
        "question": "Which of the following parameters are usually configured for a connection pool:",
        "options": [
            "Connection validation methods",
            "SQL Injection detection methods",
            "Maximum number of clients that can simultaneously access the pool",
            "Maximum number of transactions allowed"
        ],
        "answer": 0,
        "explanation": "Connection pools often include parameters such as validation methods to check the validity of database connections before use, ensuring reliability and consistency."
    },
    {
        "question": "What should be written in the blank space, in order to obtain a DataSource object, using JNDI?",
        "code_snippet": "Context ctx = new InitialContext();\nDataSource ds = (DataSource)ctx._______(\"jdbc/sample\");",
        "options": [
            "lookup",
            "findByName",
            "query",
            "lookFor"
        ],
        "answer": 0,
        "explanation": "The `lookup` method of the `Context` object is used to retrieve a JNDI resource, such as a `DataSource`, by its name."
    },
    {
        "question": "What should be written in the blank space, in order to have a JTA persistence unit that connects to the JDBC resource named \"simbaDB\"?",
        "code_snippet": "<persistence>\n<persistence-unit name=\"MyPU\" transaction-type=\"JTA\">\n<provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>\n<________>simbaDB</_______>\n</persistence-unit>\n</persistence>",
        "options": [
            "connection-pool",
            "jta-resource",
            "transactional",
            "jta-data-source"
        ],
        "answer": 3,
        "explanation": "The `jta-data-source` tag specifies the JNDI name of the JDBC resource that the JTA persistence unit should use to connect to the database."
    },
    {
        "question": "What should be written in the blank space, in order to define a page based on the base.xhtml template?",
        "code_snippet": "<ui: _____ template = \"base.xhtml\"\nxmlns=\"http://www.w3.org/1999/xhtml\"\nxmlns:ui=\"http://java.sun.com/jsf/facelets\">",
        "options": [
            "compostition",
            "extend",
            "page",
            "insert"
        ],
        "answer": 0,
        "explanation": "The `composition` tag is used in JSF to define a Facelets template-based page. It specifies that the current page is built on a given template."
    },
    {
        "question": "Which of the following statements, regarding naming services, are correct?",
        "options": [
            "A naming system is a set of naming contexts",
            "The association of name with an object is called context",
            "Retrieving an object based on its name is called binding",
            "In any naming system, each object can have attributes, apart from its name"
        ],
        "answer": 0,
        "explanation": "A naming system organizes resources into a hierarchy of naming contexts. Each context contains bindings that map names to objects."
    },
    {
        "question": "A page that is created based on a template can provide data for the abstract parts of the template using the following Facelets UI tags:",
        "options": [
            "include",
            "insert",
            "define",
            "import"
        ],
        "answer": 2,
        "explanation": ""
    },
    {
        "question": "Which of the following represent disadvantages of using the Database per Service pattern:",
        "options": [
            "Complex queries are slower to implement and execute",
            "Lack of flexibility in DBMS choice",
            "Lack of control regarding data invariants",
            "Design time coupling is higher"
        ],
        "answer": 0,
        "explanation": "In the Database per Service pattern, complex queries spanning multiple microservices are difficult to implement and can be slower due to the distributed nature of the databases."
    },
    {
        "question": "What should be written in the blank space, in order to register a REST client at runtime, using CDI managed beans?",
        "code_snippet": "_______(baseUri=\"https://localhost:8080/resources\")\n@ApplicationScoped\npublic interface Service {\n@GET @Path(\"/cats\")\nList<Sam> getCats();\n}\n",
        "options": [
            "@RegisterRestClient",
            "@ClientBuilder",
            "@RegisterResource",
            "@Inject"
        ],
        "answer": 0,
        "explanation": "The `@RegisterRestClient` annotation is used in MicroProfile to register a REST client at runtime and bind it to a specific base URI."
    },
    {
        "question": "What should be written in the blank space, in order to create the controller of a microservice, with the specified URL pattern?",
        "code_snippet": "_______(\"/hello\")\npublic class HelloController {\n@GET\npublic String sayHello() {\nreturn \"HelloWorld\";\n}\n}",
        "options": [
            "@Resource",
            "@Path",
            "@WebController",
            "@MicroController"
        ],
        "answer": 1,
        "explanation": "The `@Path` annotation in JAX-RS is used to define the base URL path for a resource class, making it accessible at the specified endpoint."
    },
    {
        "question": "The standard Java API offers the following types for representing the result of an asynchronous computation:",
        "options": [
            "CompletableFuture",
            "FuturePromise",
            "CompletableResponse",
            "AsyncScope"
        ],
        "answer": 0,
        "explanation": "The `CompletableFuture` class in Java provides a way to represent asynchronous computations and allows chaining and combining of future results."
    },
    {
        "question": "For a transactional method, what transaction type should be used (from TxType enum) in order to specify that an exception must be thrown if the invocation is done outside a transactional context",
        "options": [
            "MANDATORY",
            "REQUIRES_NEW",
            "SUPPORTS",
            "SUPPORT_THROW"
        ],
        "answer": 0,
        "explanation": "The `MANDATORY` transaction type ensures that the method must be invoked within an existing transaction context; otherwise, an exception is thrown."
    },
    {
        "question": "Which of the following statements, regarding inversion of control (IoC) principle, are true?",
        "options": [
            "Implementations should depend upon abstractions",
            "Implementations should depend upon other implementations",
            "IoC containers rely on service locator pattern",
            "IoC addresses finding object instances based on their attributes"
        ],
        "answer": 0,
        "explanation": "The IoC principle encourages implementations to depend on abstractions rather than concrete classes, promoting flexibility and reducing coupling."
    },
    {
        "question": "In order for a CDI bean to be referenced in a JSF page using EL, its class must be annotated with:",
        "options": [
            "@Page",
            "None of them, it is by default available using the unqualified class name of the bean class, after converting the first character to lower case.",
            "@Named",
            "@Model"
        ],
        "answer": 2,
        "explanation": "The `@Named` annotation makes a CDI bean accessible in JSF pages via Expression Language (EL) by registering the bean with a default name."
    },
    {
        "question": "What should be written in the blank space, in order to obtain a reference to a TimerService object?",
        "code_snippet": "@Stateless\npublic class TimerSessionBean {\n_______\n TimerService timerService;\n}\n",
        "options": [
            "@Inject",
            "@Resource",
            "@EJB",
            "@Timer"
        ],
        "answer": 1,
        "explanation": "The `@Resource` annotation is used to inject container-managed resources, such as a `TimerService`, into the EJB."
    },
    {
        "question": "What should be written in the blank space, in order to define an EJB interceptor method?",
        "code_snippet": "@Stateful\npublic class Bean {\n________\npublic Object intercept(InvocationContext ctx) {\nreturn ctx.procees();\n}\n}",
        "options": [
            "@Trace",
            "@Interceptor",
            "@AroundInvoke",
            "@Aspect"
        ],
        "answer": 2,
        "explanation": "The `@AroundInvoke` annotation is used to define an interceptor method in EJB. It allows the interception of method calls for logging, security checks, or other concerns."
    },
    {
        "question": "What should be written in the blank space, in order to prevent two clients to execute the setState method in the same time?",
        "code_snippet": "@Singleton\n@ConcurrencyManagement(CONTAINER)\npublic class Bean {\nprivate String state;\n_______(WRITE)\npublic void setState(String state) {\nthis.state = state\n}\n}\n",
        "options": [
            "@Synchronized",
            "@CyclicBarrier",
            "@Lock",
            "@concurrent"
        ],
        "answer": 2,
        "explanation": "The `@Lock(WRITE)` annotation ensures that the method is locked in a write mode, preventing concurrent execution by multiple clients."
    },
    {
        "question": "What should be written in the blank space, in order to obtain a reference to an Enterprise Java Bean instance?",
        "code_snippet": "//In a JSF managed bean\n@SessionScoped\npublic class EarumBean { ______\nprivate UllamService service;\n}",
        "options": [
            "@Stateless",
            "@Resource",
            "@Service",
            "@EJB"
        ],
        "answer": 3,
        "explanation": "The `@EJB` annotation is used to inject an instance of an Enterprise Java Bean into a managed bean, such as a JSF bean."
    },
    {
        "question": "When is EJB technology suitable to be used in an enterprise application?",
        "options": [
            "All the business logic is implemented at the Web layer",
            "We need to implement JSF composite components",
            "Transaction management is required to ensure data integrity",
            "The back-end is implemented using REST services"
        ],
        "answer": 2,
        "explanation": "EJB technology is ideal for scenarios requiring robust transaction management to ensure data consistency and integrity across multiple operations."
    },
    {
        "question": "What should be written in the blank space, in order to define an EJB method that starts a new transaction regardless of the context of the invocation?",
        "code_snippet": "@TransactionAttribute(TransactionAttributeType._______)\npublic void method(){\n //Rest of the method\n}",
        "options": [
            "REQUIRED",
            "REQUIRES_NEW",
            "CONTEXT_FREE",
            "MANDATORY"
        ],
        "answer": 1,
        "explanation": "The `REQUIRES_NEW` transaction type ensures that the method always starts a new transaction, regardless of any existing transaction context."
    },
    {
        "question": "What is the short name of the annotation that should be written in the blank space, in order to create a bean that integrates with JMS (Java Message Service)?",
        "code_snippet": "_________\npublic class SamService { \n // Rest of the class \n }",
        "options": [
            "@Queue",
            "@EJB",
            "@MessageDriven",
            "@Controller"
        ],
        "answer": 2,
        "explanation": "The `@MessageDriven` annotation is used to create a message-driven bean (MDB) that listens to a JMS destination, enabling asynchronous message processing."
    },
    {
        "question": "What should be written in the blank space, in order to define an asynchronous method in a session EJB?",
        "code_snippet": "@Asynchronous\n public ________<String> longRunningOperation() {\nRest of the method\n}",
        "options": [
            "Response",
            "Future",
            "Wait",
            "Generic"
        ],
        "answer": 1,
        "explanation": "The `Future` interface represents the result of an asynchronous computation. It is returned by methods annotated with `@Asynchronous` in EJBs."
    },
    {
        "question": "Non-repudiation refers to:",
        "options": [
            "Evaluating the effectiveness of security policies",
            "The users are who they say they are",
            "The users have specific permissions",
            "The transactions can be proved to have happened"
        ],
        "answer": 3,
        "explanation": "Non-repudiation ensures that transactions can be proven to have occurred, providing a reliable way to verify actions for auditing and accountability."
    },
    {
        "question": "Which of the following Java EE data types represents the identity of a user who is authenticated at the server level",
        "options": [
            "Realm",
            "Subject",
            "Principal",
            "Person"
        ],
        "answer": 2,
        "explanation": "The `Principal` interface in Java EE represents the identity of an authenticated user and provides access to the user's name and roles."
    },
    {
        "question": "Securing a Web application refers to verifying:",
        "options": [
            "What kind of code is executed by the application, on the client machine?",
            "Who wrote the code?",
            "Who is accessing the application?",
            "Where does the code come from?"
        ],
        "answer": 2,
        "explanation": "Securing a web application focuses on verifying who is accessing the application through authentication and authorization mechanisms."
    },
    {
        "question": "The common closure principle refers to:",
        "options": [
            "A service should implement a small set of functions",
            "The team responsible for a service should have minimal collaboration with other teams",
            "A service should not have multiple reasons to change",
            "Each service encapsulates its implementation"
        ],
        "answer": 2,
        "explanation": "The Common Closure Principle states that a service or module should not have multiple reasons to change, ensuring cohesive functionality and maintainability."
    },
    {
        "question": "Which of the following communication types are usually found in microservice architectures?",
        "options": [
            "Shared attributes at session scope",
            "Synchronous notifications",
            "Synchronous request/response",
            "Synchronous publish/subscribe"
        ],
        "answer": 2,
        "explanation": "Synchronous request/response communication is commonly used in microservice architectures for direct service-to-service interactions."
    },
    {
        "question": "A microservice should be:",
        "options": [
            "Cohesive, focusing on a single responsibility",
            "Implemented as a singleton",
            "Focused on all the aspects of a single business matter",
            "Integrated with the other microservices"
        ],
        "answer": 0,
        "explanation": "A microservice should be cohesive and focus on a single responsibility, adhering to the Single Responsibility Principle to ensure modularity and scalability."
    },
    {
        "question": "What should be written in the blank space, in order to create the controller of a microservice, with the specified URL pattern?",
        "code_snippet": "______(\"/hello\")\npublic class HelloController {\n @GET\npublic String sayHello() {\nreturn \"HelloWorld\";\n}\n}",
        "options": [
            "@Resource",
            "@Path",
            "@WebController",
            "@MicroController"
        ],
        "answer": 1,
        "explanation": "The `@Path` annotation in JAX-RS specifies the base URL for the resource class, making it accessible at the given endpoint."
    },
    {
        "question": "What could be written in the empty space in order to specify that we want to have authentication based on an XHTML page:",
        "code_snippet": "<login-config>\n<auth-method>_______</auth-method>\n<realm-name>myapp-realm</realm-name>\n<from-login-config>\n<form-login-page>/faces/login.xhtml</form-login-page>\n</form-login-config>\n</login-config>",
        "options": [
            "REALM",
            "BASIC",
            "PAGE",
            "FORM"
        ],
        "answer": 3,
        "explanation": "The `FORM` authentication method is used in Java EE to specify custom login pages for form-based authentication."
    },
    {
        "question": "Java EE offers the following specification for creating Web services:",
        "options": [
            "JAX-WS: for SOAP-based services",
            "EJB: for enterprise Web services",
            "JSF: for service frameworks",
            "JAX-MS: for microservices"
        ],
        "answer": 0,
        "explanation": "JAX-WS (Java API for XML Web Services) is the standard specification in Java EE for creating SOAP-based web services."
    },
    {
        "question": "What should be written in the blank space, in order to define a JAX-RS method that returns a \"text/plain\" response?",
        "code_snippet": "@Path(\"/dogs/lady\")\npublic class LadyResource {\n@GET\n________(MediaType.TEXT_PLAIN)\npublic String saySomething() {\nreturn \"Woof!\";\n}\n}",
        "options": [
            "@Type",
            "@Envelope",
            "@Produces",
            "@Path"
        ],
        "answer": 2,
        "explanation": "The `@Produces` annotation in JAX-RS specifies the MIME type of the response that a resource method produces, such as `MediaType.TEXT_PLAIN` for plain text."
    },
    {
        "question": "What (idempotent) HTTP method should be used to create or replace if exists a resource, at a URL known by the client.",
        "options": [
            "GET",
            "PUT",
            "UPDATE",
            "POST"
        ],
        "answer": 1,
        "explanation": "The `PUT` HTTP method is idempotent and is used to create or replace a resource at a specified URL known to the client."
    },
    {
        "question": "What should be written in the blank space, in order to define a service that uses a URI path template?",
        "code_snippet": "@Path(\"/hello/______\")\npublic class MyResource {\n@GET\npublic String hello(@PathParam(\"name\") String str) {\n return \"Hello \" + str; \n}\n}",
        "options": [
            "{name}",
            "#{name}",
            "<name>",
            "(name)"
        ],
        "answer": 0,
        "explanation": "In JAX-RS, `{name}` specifies a URI template variable that maps to the `@PathParam` annotation, allowing the variable value to be passed dynamically."
    },
    {
        "question": "A JDBC resource named rem is defined, using the connection pool resource named mollitia. What should be written in the blank space, in order to inject a DataSource object?",
        "code_snippet": "@Resource(mappedName = \"__________\")\nDataSource ds;",
        "options": [
            "rem",
            "mollitia"
        ],
        "answer": 0,
        "explanation": "The `mappedName` attribute in the `@Resource` annotation specifies the name of the JDBC resource to be injected. In this case, `rem` refers to the defined resource."
    },
    {
        "question": "The communication between a client-stub and a server-stub in a Web service invocation is designed based on which pattern?",
        "options": [
            "Remote Proxy",
            "Builder",
            "Bridge",
            "Factory Method"
        ],
        "answer": 0,
        "explanation": "The Remote Proxy pattern is used in Web service invocations to facilitate communication between a client-stub and a server-stub. It allows method calls to be executed as if they were local, while being handled remotely."
    },
    {
        "question": "Which protocol is used in order to describe the functionalities of a classical (\"big\") Web service?",
        "options": [
            "SOAP",
            "UDDI",
            "WSDL",
            "RMI"
        ],
        "answer": 2,
        "explanation": "WSDL (Web Services Description Language) is used to describe the functionalities of a classical ('big') Web service. It provides a standard XML format for defining service interfaces and operations."
    },
    {
        "question": "What should be written in the blank space, in order to invoke a JAX-RS service?",
        "code_snippet": "Product product = ________.newClient()\n    .target(\"http://localhost:8080/resources/products/1\")\n    .request(MediaType.APPLICATION_JSON)\n    .get(Product.class);",
        "options": [
            "HttpResponse",
            "URLConnection",
            "HttpBuilder",
            "ClientBuilder"
        ],
        "answer": 3,
        "explanation": "The `ClientBuilder` class is used to create a new `Client` instance for invoking JAX-RS services. It provides a fluent API for constructing requests and handling responses."
    },
    {
        "question": "What should be written in the blank space in order to expose a method as a JAX-WS Web service?",
        "code_snippet": "@________\npublic class Hello {\n    @WebMethod\n    public String sayHello(String name) {\n        return \"Hello \" + name + \"!\";\n    }\n}",
        "options": [
            "@WebService",
            "@Service",
            "@Path",
            "@WebController"
        ],
        "answer": 0,
        "explanation": "The `@WebService` annotation is used to declare a class as a JAX-WS Web Service. It exposes the class methods annotated with `@WebMethod` as web service operations."
    },
    {
        "question": "The technique employed in order to create a JAX-RS Response uses the following design pattern:",
        "options": [
            "Builder",
            "Singleton",
            "Strategy",
            "Prototype"
        ],
        "answer": 0,
        "explanation": "The `Builder` design pattern is used in JAX-RS to construct `Response` objects step by step. It provides a flexible way to create immutable objects with complex configurations."
    },
    {
        "question": "What should be written in the blank space, in order to obtain the property with the name \"key\" from microprofile-config.properties configuration file?",
        "code_snippet": "@Inject\n__________ (name = \"key\")\nprivate String value;",
        "options": [
            "@ConfigProperty",
            "@Resource",
            "@ConfigKey",
            "@Property"
        ],
        "answer": 0,
        "explanation": "The `@ConfigProperty` annotation is used in MicroProfile to inject configuration properties defined in a `microprofile-config.properties` file. By specifying the `name` attribute, the property value can be injected into the field."
    },
    {
        "question": "Which of the following communication types are usually found in microservice architectures?",
        "options": [
            "Synchronous publish/subscribe",
            "Asynchronous publish/subscribe",
            "Shared attributes at application scope",
            "Synchronous notifications"
        ],
        "answer": 1,
        "explanation": "Asynchronous publish/subscribe is commonly used in microservice architectures to decouple services, enabling them to communicate efficiently without direct dependencies or blocking calls."
    },
    {
        "question": "What should be written in the blank space, in order to create the controller of a microservice, with the specified URL pattern?",
        "code_snippet": "@__________(\"/hello\")\npublic class HelloController {\n    @GET\n    public String sayHello() {\n        return \"Hello World\";\n    }\n}",
        "options": [
            "@Resource",
            "@Path",
            "@WebController",
            "@MicroController"
        ],
        "answer": 1,
        "explanation": "The `@Path` annotation is used in JAX-RS to define the base URI for a resource class. It maps the URL pattern to the resource class, allowing it to handle requests sent to that path."
    },
    {
        "question": "Which of the following methods are described by the javax.servlet.Filter interface?",
        "options": [
            "doFilter(ServletRequest req, ServletResponse res, FilterChain chain)",
            "doFilter(FilterRequest req, FilterResponse res, FilterChain chain)",
            "service(FilterRequest req, FilterResponse res, FilterChain chain)"
        ],
        "answer": 0,
        "explanation": "The `doFilter` method is the core of the `Filter` interface. It processes requests and responses, allowing filters to transform or examine them before passing them along the chain."
    },
    {
        "question": "Which of the following methods are described by the javax.servlet.Filter interface?",
        "options": [
            "doFilter(FilterRequest req, FilterResponse res, FilterChain chain)",
            "destroy()",
            "service(FilterRequest req, FilterResponse res, FilterChain chain)"
        ],
        "answer": 1,
        "explanation": "The `destroy` method is part of the `Filter` lifecycle and is invoked by the container when the filter is taken out of service, allowing cleanup activities to be performed."
    },
    {
        "question": "Which of the following statements, regarding web listeners, are correct?",
        "options": [
            "They respond to application lifecycle changes.",
            "Each Web component can have multiple listeners attached, forming a listener chain.",
            "All listeners have access to the request and response objects."
        ],
        "answer": 0,
        "explanation": "Web listeners, such as `ServletContextListener`, can respond to application lifecycle changes like startup and shutdown, allowing developers to execute initialization or cleanup tasks."
    },
    {
        "question": "Which of the following statements, regarding web listeners, are correct?",
        "options": [
            "Could be used in order to track Web sessions created or destroyed by the server.",
            "Each Web component can have multiple listeners attached, forming a listener chain.",
            "All listeners have access to the request and response objects."
        ],
        "answer": 0,
        "explanation": "Web listeners, such as `HttpSessionListener`, are designed to track web sessions created or destroyed by the server, making it useful for session monitoring and management."
    },
    {
        "question": "Each question addresses a set of topics. What should be written in the following JPQL query, in order to obtain the questions from a specific topic?",
        "code_snippet": "select q from Question q ________ q.topics as t where t = :topic",
        "options": [
            "join",
            "fetch",
            "link",
            "bind"
        ],
        "answer": 0,
        "explanation": "The `join` keyword in JPQL is used to associate an entity with its related entities in a query, allowing the retrieval of questions that are related to a specific topic."
    },
    {
        "question": "Rewrite the following JSP expression, using JSP expression language (EL):",
        "code_snippet": "request.getHeader(\"user-agent\");",
        "options": [
            "${header[\"user-agent\"]}",
            "${request.header[\"user-agent\"]}",
            "${headers[\"user-agent\"]}",
            "${header.get(\"user-agent\")}"
        ],
        "answer": 0,
        "explanation": "The correct syntax to access the `user-agent` HTTP header using JSP Expression Language (EL) is `${header[\"user-agent\"]}`, which directly references the request header map."
    },
    {
        "question": "What is the class name that should be written in both blank spaces, in order to have a valid Web listener class?",
        "code_snippet": "public class UtListener implements ServletContextListener {\n public void contextInitialized(__________ event) {}\n public void contextDestroyed(__________ event) {}\n}",
        "options": [
            "ServletContextEvent",
            "HttpServletEvent",
            "ContextEvent",
            "ServletEvent"
        ],
        "answer": 0,
        "explanation": "The `ServletContextEvent` class is passed as a parameter to the methods of the `ServletContextListener` interface. It provides access to the `ServletContext` during initialization and destruction."
    },
    {
        "question": "Which of the following statements, regarding JTA transactions, are correct?",
        "options": [
            "JTA demarcates transactions in a manner that is independent of the transaction manager implementation.",
            "The user has to invoke commit or rollback for each container managed transaction.",
            "A JTA transaction can operate on a single database."
        ],
        "answer": 0,
        "explanation": "JTA provides a standard way to manage transactions, abstracting the details of the transaction manager implementation to ensure independence and compatibility across systems."
    },
    {
        "question": "Which of the following statements, regarding JTA transactions, are correct?",
        "options": [
            "The user has to invoke commit or rollback for each container managed transaction.",
            "A JTA transaction can operate on a single database.",
            "It is possible for the user to explicitly manage the transaction boundaries."
        ],
        "answer": 2,
        "explanation": "JTA allows users to explicitly manage transaction boundaries by using the `UserTransaction` API, providing fine-grained control over transaction commit and rollback."
    },
    {
        "question": "Consider em an EntityManager object. What should be written in the blank space in order to finish the transaction, assuming it is successful?",
        "code_snippet": "em.getTransaction().begin();\n// Some operations\n// Everything is ok\nem.getTransaction().________();",
        "options": [
            "commit",
            "close",
            "complete",
            "end"
        ],
        "answer": 0,
        "explanation": "The `commit` method is called on the `EntityTransaction` object to successfully complete and persist the changes made during the transaction."
    },
    {
        "question": "Consider em an EntityManager object. What should be written in the blank space in order to cancel the transaction, assuming something went wrong?",
        "code_snippet": "em.getTransaction().begin();\n// Some operations\n// Something went wrong\nem.getTransaction().________();",
        "options": [
            "rollback",
            "cancel",
            "revert",
            "abort"
        ],
        "answer": 0,
        "explanation": "The `rollback` method is called on the `EntityTransaction` object to cancel the transaction and undo any changes made during the transaction."
    },
    {
        "question": "Which of the following statements, regarding Java EE resources (objects injected via @Resource annotation), are correct?",
        "options": [
            "A messaging Queue is considered a resource.",
            "A Web Filter is considered a resource.",
            "Each resource has a unique uniform resource identifier (URI)."
        ],
        "answer": 0,
        "explanation": "A messaging Queue, such as JMS Queue, is considered a resource and can be injected using the `@Resource` annotation in Java EE."
    },
    {
        "question": "Which of the following statements, regarding Java EE resources (objects injected via @Resource annotation), are correct?",
        "options": [
            "A Web Filter is considered a resource.",
            "A database DataSource is considered a resource.",
            "Each resource has a unique uniform resource identifier (URI)."
        ],
        "answer": 1,
        "explanation": "A database `DataSource` is considered a resource in Java EE and is commonly injected using the `@Resource` annotation to facilitate database connections."
    },
    {
        "question": "Which of the following statements, regarding JNDI (Java Naming and Directory Interface), are correct?",
        "options": [
            "It allows server-side components to locate resources based on their names.",
            "A JNDI bind operation must be performed before any lookup invocation.",
            "A JNDI provider must offer at least a DataSource implementation."
        ],
        "answer": 0,
        "explanation": "JNDI enables server-side components to locate resources, such as databases or EJBs, using a naming system based on abstract names."
    },
    {
        "question": "Which of the following statements, regarding JNDI (Java Naming and Directory Interface), are correct?",
        "options": [
            "A JNDI bind operation must be performed before any lookup invocation.",
            "A JNDI provider must offer at least a DataSource implementation.",
            "JNDI allows creating mappings between abstract names and Java objects, in a naming context."
        ],
        "answer": 2,
        "explanation": "JNDI supports creating mappings between abstract names and Java objects in a naming context, facilitating the management and discovery of resources."
    },
    {
        "question": "What should be written in the blank space, in order to add the following mapping to a JNDI context?",
        "code_snippet": "Context context = new InitialContext();\nString name = \"Gracie\";\nDog dog = new Dog(name);\ncontext.________(name, dog);",
        "options": [
            "bind",
            "set",
            "map",
            "link"
        ],
        "answer": 0,
        "explanation": "The `bind` method is used to associate a name with an object in the JNDI context, enabling the object to be looked up using the specified name."
    },
    {
        "question": "Which statements, regarding Facelets technology, are correct?",
        "options": [
            "Uses JSP for creating Web pages.",
            "Offers support for creating pages from templates.",
            "It is an alternative framework to Java Server Faces (JSF)."
        ],
        "answer": 1,
        "explanation": "Facelets is the default view declaration language for Java Server Faces (JSF) and provides support for creating pages based on templates, simplifying web page development."
    },
    {
        "question": "Which statements, regarding Facelets technology, are correct?",
        "options": [
            "Uses JSP for creating Web pages.",
            "Offers support for creating composite components.",
            "It is an alternative framework to Java Server Faces (JSF)."
        ],
        "answer": 1,
        "explanation": "Facelets allows developers to create composite components, which are reusable UI components that can be used across different parts of the application."
    },
    {
        "question": "Which of the following application concerns could be considered aspects?",
        "options": [
            "Messaging",
            "Security",
            "Connection pooling",
            "Tracing"
        ],
        "answer": 1,
        "explanation": "Security is a cross-cutting concern because it applies to multiple layers of an application, such as authentication and authorization, without being tied to its business logic."
    },
    {
        "question": "Which of the following application concerns could be considered aspects?",
        "options": [
            "Messaging",
            "Connection pooling",
            "Tracing"
        ],
        "answer": 2,
        "explanation": "Tracing is a cross-cutting concern because it involves monitoring and logging application behavior across various components, separate from the business logic."
    },
    {
        "question": "What should be written in the blank space, in order to define a CDI interceptor?",
        "code_snippet": "@Interceptor\npublic class MyInterceptor implements Serializable {\n    @AroundInvoke\n    public Object log(__________ ctx) {\n        return ctx.proceed();\n    }\n}",
        "options": [
            "InvocationContext",
            "InterceptorContext",
            "ContextObject",
            "InterceptContext"
        ],
        "answer": 0,
        "explanation": "The `InvocationContext` interface provides metadata about the invocation of a business method or lifecycle callback, allowing the interceptor to access method parameters, proceed with the invocation, or handle the result."
    },
    {
        "question": "What should be written in the blank space, in order to declaratively control transaction boundaries on a CDI bean method?",
        "code_snippet": "@RequestScoped\npublic class MyCDIBean {\n    @PersistenceContext EntityManager em;\n\n    _________\n    public void persist(Object obj) {\n        em.persist(obj);\n    }\n}",
        "options": [
            "@Transactional",
            "@TransactionScoped",
            "@TransactionManager",
            "@TransactionBound"
        ],
        "answer": 0,
        "explanation": "The `@Transactional` annotation is used to declaratively manage transactions in CDI beans. It ensures that the `persist` method is executed within a transactional context, handling commit or rollback as needed."
    },
    {
        "question": "The ScooterImpl implements the Scooter interface. What should be written in the blank space in order to obtain an object of type ScooterImpl?",
        "code_snippet": "public class ScooterService {\n    _________ Scooter scooter;\n}",
        "options": [
            "@Inject",
            "@Autowired",
            "@Resource",
            "@Provide"
        ],
        "answer": 0,
        "explanation": "The `@Inject` annotation is used in CDI (Contexts and Dependency Injection) to automatically inject a dependency of type `ScooterImpl` into the `Scooter` field at runtime."
    },
    {
        "question": "What should be written in the blank space, in order to define two implementations of a bean type and choose at deployment time (specified in beans.xml) which one will be used?",
        "code_snippet": "_________\nclass CharlieImpl implements Pettable {\n    // Rest of the class\n}\n\n_________\nclass LilyImpl implements Pettable {\n    // Rest of the class\n}",
        "options": [
            "@Alternative",
            "@Qualifier",
            "@Inject",
            "@Produces"
        ],
        "answer": 0,
        "explanation": "The `@Alternative` annotation is used to define alternative implementations of a bean type. At deployment time, the specific implementation can be chosen by enabling the corresponding alternative in the `beans.xml` descriptor."
    },
    {
        "question": "What should be written in the blank space, in order to define a method that will be a source of bean instances, and it will be used like this @Inject @Random int number;?",
        "code_snippet": "__________\n@Random int getRandomNumber() {\n    return new Random().nextInt(100);\n}",
        "options": [
            "@Produces",
            "@Provider",
            "@Factory",
            "@Supplier"
        ],
        "answer": 0,
        "explanation": "The `@Produces` annotation is used in CDI to define a producer method, which is responsible for creating and providing an instance of a bean. The method annotated with `@Produces` is invoked whenever the bean is injected into another component"
    },
    {
        "question": "Which of the following statements, regarding EJB container-managed transactions, are correct?",
        "options": [
            "An EJB method participates in a transaction if it is annotated with @Transactional.",
            "The container commits the transaction just before the method exits.",
            "When a checked exception is thrown, the container will automatically rollback the transaction."
        ],
        "answer": 1,
        "explanations": "The EJB container automatically commits the transaction just before the method exits if the transaction completes successfully, ensuring proper transactional closure."
    },
    {
        "question": "Which of the following statements, regarding EJB container-managed transactions, are correct?",
        "options": [
            "An EJB method participates in a transaction if it is annotated with @Transactional.",
            "The EJB container sets by default the boundaries of the transactions.",
            "When a checked exception is thrown, the container will automatically rollback the transaction."
        ],
        "answer": 1,
        "explanations": "By default, the EJB container manages the boundaries of the transactions, allowing developers to focus on business logic while the container handles transaction demarcation."
    }
]
